// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/sorinmanole/go/pkg/mod/github.com/yalue/onnxruntime_go@v1.23.0/onnxruntime_go.go:1:1
// This library wraps the C "onnxruntime" library maintained at
// https://github.com/microsoft/onnxruntime.  It seeks to provide as simple an
// interface as possible to load and run ONNX-format neural networks from
// Go code.
package onnxruntime_go; import _cgo_unsafe "unsafe"

import (
	"fmt"
	"strings"
	"unsafe"
)

// #cgo CFLAGS: -O2 -g
//
// #include "onnxruntime_wrapper.h"
import _ "unsafe"

// This string should be the path to onnxruntime.so, or onnxruntime.dll.
var onnxSharedLibraryPath string

// For simplicity, this library maintains a single ORT environment internally.
var ortEnv * /*line :22:13*/_Ctype_OrtEnv /*line :22:21*/

// We also keep a single OrtMemoryInfo value around, since we only support CPU
// allocations for now.
var ortMemoryInfo * /*line :26:20*/_Ctype_OrtMemoryInfo /*line :26:35*/

var NotInitializedError error = fmt.Errorf("InitializeRuntime() has either " +
	"not yet been called, or did not return successfully")

var ZeroShapeLengthError error = fmt.Errorf("The shape has no dimensions")

var ShapeOverflowError error = fmt.Errorf("The shape's flattened size " +
	"overflows an int64")

// This type of error is returned when we attempt to validate a tensor that has
// a negative or 0 dimension.
type BadShapeDimensionError struct {
	DimensionIndex int
	DimensionSize  int64
}

func (e *BadShapeDimensionError) Error() string {
	return fmt.Sprintf("Dimension %d of the shape has invalid value %d",
		e.DimensionIndex, e.DimensionSize)
}

// GetVersion return version of the Onnxruntime library for logging.
func GetVersion() string {
	return ( /*line :50:9*/_Cfunc_GoString /*line :50:18*/)(( /*line :50:20*/_Cfunc_GetVersion /*line :50:31*/)())
}

// Does two things: converts the given OrtStatus to a Go error, and releases
// the status. If the status is nil, this does nothing and returns nil.
func statusToError(status * /*line :55:28*/_Ctype_OrtStatus /*line :55:39*/) error {
	if status == nil {
		return nil
	}
	msg := func() *_Ctype_char{ _cgo0 := /*line :59:27*/status; _cgoCheckPointer(_cgo0, nil); return /*line :59:34*/_Cfunc_GetErrorMessage(_cgo0); }()
	goMsg := ( /*line :60:11*/_Cfunc_GoString /*line :60:20*/)(msg)
	func() { _cgo0 := /*line :61:21*/status; _cgoCheckPointer(_cgo0, nil); /*line :61:28*/_Cfunc_ReleaseOrtStatus(_cgo0); }()
	return fmt.Errorf("%s", strings.TrimSpace(goMsg))
}

// Use this function to set the path to the "onnxruntime.so" or
// "onnxruntime.dll" function. By default, it will be set to "onnxruntime.so"
// on non-Windows systems, and "onnxruntime.dll" on Windows. Users wishing to
// specify a particular location of this library must call this function prior
// to calling onnxruntime.InitializeEnvironment().
func SetSharedLibraryPath(path string) {
	onnxSharedLibraryPath = path
}

// Returns false if the onnxruntime package is not initialized. Called
// internally by several functions, to avoid segfaulting if
// InitializeEnvironment hasn't been called yet.
func IsInitialized() bool {
	return ortEnv != nil
}

// Call this function, optionally with one or more EnvironmentOption, to
// initialize the internal onnxruntime environment. If this doesn't return an
// error, the caller will be responsible for calling DestroyEnvironment to free
// the onnxruntime state when no longer needed.
func InitializeEnvironment(opts ...EnvironmentOption) error {
	if IsInitialized() {
		return fmt.Errorf("The onnxruntime has already been initialized")
	}
	// Do the windows- or linux- specific initialization first.
	e := platformInitializeEnvironment()
	if e != nil {
		return fmt.Errorf("Platform-specific initialization failed: %w", e)
	}

	name := ( /*line :95:10*/_Cfunc_CString /*line :95:18*/)("Golang onnxruntime environment")
	defer func() func() { _cgo0 := /*line :96:15*/unsafe.Pointer(name); return func() { _cgoCheckPointer(_cgo0, nil); /*line :96:36*/_Cfunc_free(_cgo0); }}()()
	status := func() *_Ctype_struct_OrtStatus{ var _cgo0 *_Ctype_char = /*line :97:27*/name; _cgoBase1 := /*line :97:33*/&ortEnv; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :97:41*/_Cfunc_CreateOrtEnv(_cgo0, _cgo1); }()
	if status != nil {
		return fmt.Errorf("Error creating ORT environment: %w",
			statusToError(status))
	}

	for _, opt := range opts {
		if status := opt(ortEnv); status != nil {
			DestroyEnvironment()
			return fmt.Errorf("Error applying ORT environment option: %w",
				statusToError(status))
		}
	}

	status = func() *_Ctype_struct_OrtStatus{ _cgoBase0 := /*line :111:33*/&ortMemoryInfo; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :111:48*/_Cfunc_CreateOrtMemoryInfo(_cgo0); }()
	if status != nil {
		DestroyEnvironment()
		return fmt.Errorf("Error creating ORT memory info: %w",
			statusToError(status))
	}
	return nil
}

// Call this function to cleanup the internal onnxruntime environment when it
// is no longer needed.
func DestroyEnvironment() error {
	var e error
	if !IsInitialized() {
		return NotInitializedError
	}
	if ortMemoryInfo != nil {
		func() { _cgo0 := /*line :128:26*/ortMemoryInfo; _cgoCheckPointer(_cgo0, nil); /*line :128:40*/_Cfunc_ReleaseOrtMemoryInfo(_cgo0); }()
		ortMemoryInfo = nil
	}
	if ortEnv != nil {
		func() { _cgo0 := /*line :132:19*/ortEnv; _cgoCheckPointer(_cgo0, nil); /*line :132:26*/_Cfunc_ReleaseOrtEnv(_cgo0); }()
		ortEnv = nil
	}

	// platformCleanup primarily unloads the library, so we need to call it
	// last, after any functions that make use of the ORT API.
	e = platformCleanup()
	if e != nil {
		return fmt.Errorf("Platform-specific cleanup failed: %w", e)
	}
	return nil
}

// EnvironmentOption is a functional option that can be provided during
// initialization of an ORT Environment.
type EnvironmentOption func(* /*line :147:30*/_Ctype_OrtEnv /*line :147:38*/) * /*line :147:41*/_Ctype_OrtStatus /*line :147:52*/

// Wraps the OrtLoggingLevel enum
type LoggingLevel int

const (
	LoggingLevelVerbose = ( /*line :153:24*/_Ciconst_ORT_LOGGING_LEVEL_VERBOSE /*line :153:50*/)
	LoggingLevelInfo    = ( /*line :154:24*/_Ciconst_ORT_LOGGING_LEVEL_INFO /*line :154:47*/)
	LoggingLevelWarning = ( /*line :155:24*/_Ciconst_ORT_LOGGING_LEVEL_WARNING /*line :155:50*/)
	LoggingLevelError   = ( /*line :156:24*/_Ciconst_ORT_LOGGING_LEVEL_ERROR /*line :156:48*/)
	LoggingLevelFatal   = ( /*line :157:24*/_Ciconst_ORT_LOGGING_LEVEL_FATAL /*line :157:48*/)
)

func (l LoggingLevel) String() string {
	switch l {
	case LoggingLevelVerbose:
		return "ORT_LOGGING_LEVEL_VERBOSE"
	case LoggingLevelInfo:
		return "ORT_LOGGING_LEVEL_INFO"
	case LoggingLevelWarning:
		return "ORT_LOGGING_LEVEL_WARNING"
	case LoggingLevelError:
		return "ORT_LOGGING_LEVEL_ERROR"
	case LoggingLevelFatal:
		return "ORT_LOGGING_LEVEL_FATAL"
	}
	return fmt.Sprintf("<Unknown logging level %d>", int(l))
}

// WithLogLevelVerbose is an EnvironmentOption that will set the ORT
// Environment logging to emit verbose informational messages (least
// severe) along with all messages of greater severity.
func WithLogLevelVerbose() EnvironmentOption {
	return func(e * /*line :180:17*/_Ctype_OrtEnv /*line :180:25*/) * /*line :180:28*/_Ctype_OrtStatus /*line :180:39*/ {
		return func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :181:40*/e; var _cgo1 _Ctype_OrtLoggingLevel = _Ctype_OrtLoggingLevel /*line :182:21*/(LoggingLevelVerbose); _cgoCheckPointer(_cgo0, nil); return /*line :182:43*/_Cfunc_UpdateEnvWithCustomLogLevel(_cgo0, _cgo1); }()
	}
}

// WithLogLevelInfo is an EnvironmentOption that will set the ORT Environment
// logging to emit informational messages along with all messages of greater
// severity.
func WithLogLevelInfo() EnvironmentOption {
	return func(e * /*line :190:17*/_Ctype_OrtEnv /*line :190:25*/) * /*line :190:28*/_Ctype_OrtStatus /*line :190:39*/ {
		return func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :191:40*/e; var _cgo1 _Ctype_OrtLoggingLevel = _Ctype_OrtLoggingLevel /*line :192:21*/(LoggingLevelInfo); _cgoCheckPointer(_cgo0, nil); return /*line :192:40*/_Cfunc_UpdateEnvWithCustomLogLevel(_cgo0, _cgo1); }()
	}
}

// WithLogLevelWarning is an EnvironmentOption that will set the ORT
// Environment logging to emit warning messages along with all messages of
// greater severity.
func WithLogLevelWarning() EnvironmentOption {
	return func(e * /*line :200:17*/_Ctype_OrtEnv /*line :200:25*/) * /*line :200:28*/_Ctype_OrtStatus /*line :200:39*/ {
		return func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :201:40*/e; var _cgo1 _Ctype_OrtLoggingLevel = _Ctype_OrtLoggingLevel /*line :202:21*/(LoggingLevelWarning); _cgoCheckPointer(_cgo0, nil); return /*line :202:43*/_Cfunc_UpdateEnvWithCustomLogLevel(_cgo0, _cgo1); }()
	}
}

// WithLogLevelError is an EnvironmentOption that will set the ORT
// Environment logging to emit error messages along with all messages of
// greater severity. This is the default logging level.
func WithLogLevelError() EnvironmentOption {
	return func(e * /*line :210:17*/_Ctype_OrtEnv /*line :210:25*/) * /*line :210:28*/_Ctype_OrtStatus /*line :210:39*/ {
		return func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :211:40*/e; var _cgo1 _Ctype_OrtLoggingLevel = _Ctype_OrtLoggingLevel /*line :212:21*/(LoggingLevelError); _cgoCheckPointer(_cgo0, nil); return /*line :212:41*/_Cfunc_UpdateEnvWithCustomLogLevel(_cgo0, _cgo1); }()
	}
}

// WithLogLevelFatal is an EnvironmentOption that will set the ORT
// Environment logging to emit only fatal error messages (most severe).
func WithLogLevelFatal() EnvironmentOption {
	return func(e * /*line :219:17*/_Ctype_OrtEnv /*line :219:25*/) * /*line :219:28*/_Ctype_OrtStatus /*line :219:39*/ {
		return func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :220:40*/e; var _cgo1 _Ctype_OrtLoggingLevel = _Ctype_OrtLoggingLevel /*line :221:21*/(LoggingLevelFatal); _cgoCheckPointer(_cgo0, nil); return /*line :221:41*/_Cfunc_UpdateEnvWithCustomLogLevel(_cgo0, _cgo1); }()
	}
}

// Disables telemetry events for the onnxruntime environment. Must be called
// after initializing the environment using InitializeEnvironment(). It is
// unclear from the onnxruntime docs whether this will cause an error or
// silently return if telemetry is already disabled.
func DisableTelemetry() error {
	if !IsInitialized() {
		return NotInitializedError
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :233:31*/ortEnv; _cgoCheckPointer(_cgo0, nil); return /*line :233:38*/_Cfunc_DisableTelemetry(_cgo0); }()
	if status != nil {
		return fmt.Errorf("Error disabling onnxruntime telemetry: %w",
			statusToError(status))
	}
	return nil
}

// Enables telemetry events for the onnxruntime environment. Must be called
// after initializing the environment using InitializeEnvironment(). It is
// unclear from the onnxruntime docs whether this will cause an error or
// silently return if telemetry is already enabled.
func EnableTelemetry() error {
	if !IsInitialized() {
		return NotInitializedError
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :249:30*/ortEnv; _cgoCheckPointer(_cgo0, nil); return /*line :249:37*/_Cfunc_EnableTelemetry(_cgo0); }()
	if status != nil {
		return fmt.Errorf("Error enabling onnxruntime telemetry: %w",
			statusToError(status))
	}
	return nil
}

// Sets the environmnent-wide log severity level. The argument must be one of
// LoggingLevelVerbose, LoggingLevelInfo, LoggingLevelWarning,
// LoggingLevelError, or LoggingLevelFatal. Must only be used after the
// environment has been initialized.
func SetEnvironmentLogLevel(level LoggingLevel) error {
	if !IsInitialized() {
		return NotInitializedError
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :265:42*/ortEnv; var _cgo1 _Ctype_OrtLoggingLevel = _Ctype_OrtLoggingLevel /*line :265:67*/(level); _cgoCheckPointer(_cgo0, nil); return /*line :265:75*/_Cfunc_UpdateEnvWithCustomLogLevel(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// The Shape type holds the shape of the tensors used by the network input and
// outputs.
type Shape []int64

// Returns a Shape, with the given dimensions.
func NewShape(dimensions ...int64) Shape {
	return Shape(dimensions)
}

// Returns the total number of elements in a tensor with the given shape. Note
// that this may be an invalid value due to overflow or negative dimensions. If
// a shape comes from an untrusted source, it may be a good practice to call
// Validate() prior to trusting the FlattenedSize.
func (s Shape) FlattenedSize() int64 {
	if len(s) == 0 {
		return 0
	}
	toReturn := s[0]
	for i := 1; i < len(s); i++ {
		toReturn *= s[i]
	}
	return toReturn
}

// Returns a non-nil error if the shape has bad or zero dimensions. May return
// a ZeroShapeLengthError, a ShapeOverflowError, or a BadShapeDimensionError.
// In the future, this may return other types of errors if it others become
// necessary.
func (s Shape) Validate() error {
	if len(s) == 0 {
		return ZeroShapeLengthError
	}
	hasZeroDim := false
	// If any dimension is negative, return an error. Also keep track of
	// whether any dimension is 0.
	for i, v := range s {
		if v < 0 {
			return &BadShapeDimensionError{
				DimensionIndex: i,
				DimensionSize:  v,
			}
		}
		if v == 0 {
			hasZeroDim = true
		}
	}

	// We don't need to check for overflow if one or more dimension was 0.
	if hasZeroDim {
		return nil
	}

	// All dimensions are positive and nonzero, so make sure that multiplying
	// them together won't overflow an int64.
	flattenedSize := s[0]
	for i := 1; i < len(s); i++ {
		tmp := flattenedSize * s[i]
		if tmp < flattenedSize {
			return ShapeOverflowError
		}
		flattenedSize = tmp
	}
	return nil
}

// Makes and returns a deep copy of the Shape.
func (s Shape) Clone() Shape {
	toReturn := make([]int64, len(s))
	copy(toReturn, []int64(s))
	return Shape(toReturn)
}

func (s Shape) String() string {
	return fmt.Sprintf("%v", []int64(s))
}

// Returns true if both shapes match in every dimension.
func (s Shape) Equals(other Shape) bool {
	if len(s) != len(other) {
		return false
	}
	for i := 0; i < len(s); i++ {
		if s[i] != other[i] {
			return false
		}
	}
	return true
}

// This wraps internal implementation details to avoid exposing them to users
// via the Value interface.
type ValueInternalData struct {
	ortValue * /*line :364:12*/_Ctype_OrtValue /*line :364:22*/
}

// An interface for managing tensors or other onnxruntime values where we don't
// necessarily need to access the underlying data slice. All typed tensors will
// support this interface regardless of the underlying data type.
type Value interface {
	DataType()  /*line :371:13*/_Ctype_ONNXTensorElementDataType /*line :371:40*/
	GetShape() Shape
	Destroy() error
	GetInternals() *ValueInternalData
	ZeroContents()
	GetONNXType() ONNXType
}

// Used to manage all input and output data for onnxruntime networks. A Tensor
// always has an associated type and refers to data contained in an underlying
// Go slice. New tensors should be created using the NewTensor or
// NewEmptyTensor functions, and must be destroyed using the Destroy function
// when no longer needed.
type Tensor[T TensorData] struct {
	// The shape of the tensor
	shape Shape
	// The go slice containing the flattened data that backs the ONNX tensor.
	data []T
	// The number of bytes taken by the data slice.
	dataSize uintptr
	// The underlying ONNX value we use with the C API.
	ortValue * /*line :392:12*/_Ctype_OrtValue /*line :392:22*/
}

// Cleans up and frees the memory associated with this tensor.
func (t *Tensor[_]) Destroy() error {
	func() { _cgo0 := /*line :397:20*/t.ortValue; _cgoCheckPointer(_cgo0, nil); /*line :397:31*/_Cfunc_ReleaseOrtValue(_cgo0); }()
	t.ortValue = nil
	t.data = nil
	t.dataSize = 0
	t.shape = nil
	return nil
}

// Returns the slice containing the tensor's underlying data. The contents of
// the slice can be read or written to get or set the tensor's contents.
func (t *Tensor[T]) GetData() []T {
	return t.data
}

// Returns the value from the ONNXTensorElementDataType C enum corresponding to
// the type of data held by this tensor.
//
// NOTE: This function was added prior to the introduction of the
// Go TensorElementDataType int wrapping the C enum, so it still returns the
// CGo type.
func (t *Tensor[T]) DataType()  /*line :417:32*/_Ctype_ONNXTensorElementDataType /*line :417:59*/ {
	return GetTensorElementDataType[T]()
}

// Always returns ONNXTypeTensor for any Tensor[T] even if the underlying
// tensor is invalid for some reason.
func (t *Tensor[_]) GetONNXType() ONNXType {
	return ONNXTypeTensor
}

// Returns the shape of the tensor. The returned shape is only a copy;
// modifying this does *not* change the shape of the underlying tensor.
// (Modifying the tensor's shape can only be accomplished by Destroying and
// recreating the tensor with the same data.)
func (t *Tensor[_]) GetShape() Shape {
	return t.shape.Clone()
}

func (t *Tensor[_]) GetInternals() *ValueInternalData {
	return &ValueInternalData{
		ortValue: t.ortValue,
	}
}

// Sets every element in the tensor's underlying data slice to 0.
func (t *Tensor[T]) ZeroContents() {
	func() _cgo_unsafe.Pointer{ _cgoIndex0 := &/*line :443:27*/t.data; _cgo0 := /*line :443:11*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :443:39*/0; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :443:50*/(t.dataSize); _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :443:63*/_Cfunc_memset(_cgo0, _cgo1, _cgo2); }()
}

// Makes a deep copy of the tensor, including its ONNXRuntime value. The Tensor
// returned by this function must be destroyed when no longer needed. The
// returned tensor will also no longer refer to the same underlying data; use
// GetData() to obtain the new underlying slice.
func (t *Tensor[T]) Clone() (*Tensor[T], error) {
	toReturn, e := NewEmptyTensor[T](t.shape)
	if e != nil {
		return nil, fmt.Errorf("Error allocating tensor clone: %w", e)
	}
	copy(toReturn.GetData(), t.data)
	return toReturn, nil
}

// Creates a new empty tensor with the given shape. The shape provided to this
// function is copied, and is no longer needed after this function returns.
func NewEmptyTensor[T TensorData](s Shape) (*Tensor[T], error) {
	e := s.Validate()
	if e != nil {
		return nil, fmt.Errorf("Invalid tensor shape: %w", e)
	}
	elementCount := s.FlattenedSize()
	data := make([]T, elementCount)
	return NewTensor(s, data)
}

// Creates a new tensor backed by an existing data slice. The shape provided to
// this function is copied, and is no longer needed after this function
// returns. If the data slice is longer than s.FlattenedSize(), then only the
// first portion of the data will be used.
func NewTensor[T TensorData](s Shape, data []T) (*Tensor[T], error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	e := s.Validate()
	if e != nil {
		return nil, fmt.Errorf("Invalid tensor shape: %w", e)
	}
	elementCount := s.FlattenedSize()
	if elementCount > int64(len(data)) {
		return nil, fmt.Errorf("The tensor's shape (%s) requires %d "+
			"elements, but only %d were provided", s, elementCount,
			len(data))
	}
	var ortValue * /*line :489:16*/_Ctype_OrtValue /*line :489:26*/
	dataType := GetTensorElementDataType[T]()

	var dataPtr unsafe.Pointer
	var dataSize uintptr
	if elementCount != 0 {
		// Only do operations that require accessing the data slice if we know
		// the Tensor's shape doesn't contain any 0 dimensions
		dataSize = unsafe.Sizeof(data[0]) * uintptr(elementCount)
		dataPtr = unsafe.Pointer(&data[0])
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :500:39*/dataPtr; var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :500:56*/(dataSize); var _cgo2 *_Ctype_int64_t = /*line :501:3*/(*_Ctype_int64_t /*line :501:14*/)(unsafe.Pointer(&s[0])); var _cgo3 _Ctype_int64_t = _Ctype_int64_t /*line :501:49*/(len(s)); _cgo4 := /*line :501:59*/ortMemoryInfo; var _cgo5 _Ctype_ONNXTensorElementDataType = /*line :502:3*/dataType; _cgoBase6 := /*line :502:13*/&ortValue; _cgo6 := _cgoBase6; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo4, nil); _cgoCheckPointer(_cgoBase6, 0 == 0); return /*line :502:23*/_Cfunc_CreateOrtTensorWithShape(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	if status != nil {
		return nil, fmt.Errorf("ORT API error creating tensor: %s",
			statusToError(status))
	}

	toReturn := Tensor[T]{
		data:     data[0:elementCount],
		dataSize: dataSize,
		shape:    s.Clone(),
		ortValue: ortValue,
	}
	return &toReturn, nil
}

// Wraps the ONNXTEnsorElementDataType enum in C.
type TensorElementDataType int

const (
	TensorElementDataTypeUndefined = ( /*line :521:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED /*line :521:75*/)
	TensorElementDataTypeFloat     = ( /*line :522:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT /*line :522:71*/)
	TensorElementDataTypeUint8     = ( /*line :523:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8 /*line :523:71*/)
	TensorElementDataTypeInt8      = ( /*line :524:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8 /*line :524:70*/)
	TensorElementDataTypeUint16    = ( /*line :525:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16 /*line :525:72*/)
	TensorElementDataTypeInt16     = ( /*line :526:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16 /*line :526:71*/)
	TensorElementDataTypeInt32     = ( /*line :527:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32 /*line :527:71*/)
	TensorElementDataTypeInt64     = ( /*line :528:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64 /*line :528:71*/)
	TensorElementDataTypeString    = ( /*line :529:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING /*line :529:72*/)
	TensorElementDataTypeBool      = ( /*line :530:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL /*line :530:70*/)
	TensorElementDataTypeFloat16   = ( /*line :531:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16 /*line :531:73*/)
	TensorElementDataTypeDouble    = ( /*line :532:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE /*line :532:72*/)
	TensorElementDataTypeUint32    = ( /*line :533:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32 /*line :533:72*/)
	TensorElementDataTypeUint64    = ( /*line :534:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64 /*line :534:72*/)

	// Not supported by onnxruntime (as of onnxruntime version 1.22.0)
	TensorElementDataTypeComplex64 = ( /*line :537:35*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64 /*line :537:75*/)
	// Not supported by onnxruntime (as of onnxruntime version 1.22.0)
	TensorElementDataTypeComplex128 = ( /*line :539:36*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128 /*line :539:77*/)

	// Non-IEEE floating-point format based on IEEE754 single-precision
	TensorElementDataTypeBFloat16 = ( /*line :542:34*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16 /*line :542:73*/)

	// 8-bit float types, introduced in onnx 1.14.  See
	// https://onnx.ai/onnx/technical/float8.html
	TensorElementDataTypeFloat8E4M3FN   = ( /*line :546:40*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FN /*line :546:83*/)
	TensorElementDataTypeFloat8E4M3FNUZ = ( /*line :547:40*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FNUZ /*line :547:85*/)
	TensorElementDataTypeFloat8E5M2     = ( /*line :548:40*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2 /*line :548:81*/)
	TensorElementDataTypeFloat8E5M2FNUZ = ( /*line :549:40*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2FNUZ /*line :549:85*/)

	// Int4 types were introduced in ONNX 1.16. See
	// https://onnx.ai/onnx/technical/int4.html
	TensorElementDataTypeUint4 = ( /*line :553:31*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT4 /*line :553:67*/)
	TensorElementDataTypeInt4  = ( /*line :554:31*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_INT4 /*line :554:66*/)
)

func (t TensorElementDataType) String() string {
	switch t {
	case TensorElementDataTypeUndefined:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED"
	case TensorElementDataTypeFloat:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT"
	case TensorElementDataTypeUint8:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8"
	case TensorElementDataTypeInt8:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8"
	case TensorElementDataTypeUint16:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16"
	case TensorElementDataTypeInt16:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16"
	case TensorElementDataTypeInt32:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32"
	case TensorElementDataTypeInt64:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64"
	case TensorElementDataTypeString:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING"
	case TensorElementDataTypeBool:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL"
	case TensorElementDataTypeFloat16:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16"
	case TensorElementDataTypeDouble:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE"
	case TensorElementDataTypeUint32:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32"
	case TensorElementDataTypeUint64:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64"
	case TensorElementDataTypeComplex64:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64"
	case TensorElementDataTypeComplex128:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128"
	case TensorElementDataTypeBFloat16:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16"
	case TensorElementDataTypeFloat8E4M3FN:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FN"
	case TensorElementDataTypeFloat8E4M3FNUZ:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FNUZ"
	case TensorElementDataTypeFloat8E5M2:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2"
	case TensorElementDataTypeFloat8E5M2FNUZ:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2FNUZ"
	case TensorElementDataTypeUint4:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT4"
	case TensorElementDataTypeInt4:
		return "ONNX_TENSOR_ELEMENT_DATA_TYPE_INT4"
	}
	return fmt.Sprintf("Unknown tensor element data type: %d", int(t))
}

// Wraps the GraphOptimizationLevel enum in C.
type GraphOptimizationLevel int

const (
	GraphOptimizationLevelDisableAll     = ( /*line :613:41*/_Ciconst_ORT_DISABLE_ALL /*line :613:57*/)
	GraphOptimizationLevelEnableBasic    = ( /*line :614:41*/_Ciconst_ORT_ENABLE_BASIC /*line :614:58*/)
	GraphOptimizationLevelEnableExtended = ( /*line :615:41*/_Ciconst_ORT_ENABLE_EXTENDED /*line :615:61*/)
	GraphOptimizationLevelEnableAll      = ( /*line :616:41*/_Ciconst_ORT_ENABLE_ALL /*line :616:56*/)
)

func (l GraphOptimizationLevel) String() string {
	switch l {
	case GraphOptimizationLevelDisableAll:
		return "ORT_DISABLE_ALL"
	case GraphOptimizationLevelEnableBasic:
		return "ORT_ENABLE_BASIC"
	case GraphOptimizationLevelEnableExtended:
		return "ORT_ENABLE_EXTENDED"
	case GraphOptimizationLevelEnableAll:
		return "ORT_ENABLE_ALL"
	}
	return fmt.Sprintf("<Invalid or unknown GraphOptimizationLevel %d>",
		int(l))
}

// This wraps an ONNX_TYPE_SEQUENCE OrtValue. Satisfies the Value interface,
// though Tensor-related functions such as ZeroContents() may be no-ops.
type Sequence struct {
	ortValue * /*line :637:12*/_Ctype_OrtValue /*line :637:22*/
	// We'll stash the values in the sequence here, so we don't need to look
	// them up, and so that users don't need to remember to free them.
	contents []Value
}

// Returns the value at the given index in the sequence or map. (In a map,
// index 0 is for keys, and 1 is for values.) Used internally when initializing
// a go Sequence or Map object.
func getSequenceOrMapValue(sequenceOrMap * /*line :646:43*/_Ctype_OrtValue /*line :646:53*/,
	index int64) (Value, error) {
	var result * /*line :648:14*/_Ctype_OrtValue /*line :648:24*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :649:23*/sequenceOrMap; var _cgo1 _Ctype_int = _Ctype_int /*line :649:43*/(index); _cgoBase2 := /*line :649:52*/&result; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :649:60*/_Cfunc_GetValue(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return nil, fmt.Errorf("Error getting value of index %d: %s", index,
			statusToError(status))
	}
	return createGoValueFromOrtValue(result)
}

// Creates a new ONNX sequence with the given contents. The returned Sequence
// must be Destroyed by the caller when no longer needed. Destroying the
// Sequence created by this function does _not_ destroy the Values it was
// created with, so the caller is still responsible for destroying them
// as well.
//
// The contents of a sequence are subject to additional constraints. I can't
// find mention of some of these in the C API docs, but they are enforced by
// the onnxruntime API. Notably: all elements of the sequence must have the
// same type, and all elements must be either maps or tensors. Finally, the
// sequence must contain at least one element, and none of the elements may be
// nil. There may be other constraints that I am unaware of, as well.
func NewSequence(contents []Value) (*Sequence, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	length := int64(len(contents))
	if length == 0 {
		return nil, fmt.Errorf("Sequences must contain at least 1 element")
	}
	ortValues := make([]* /*line :677:23*/_Ctype_OrtValue /*line :677:33*/, length)
	for i, v := range contents {
		if v == nil {
			return nil, fmt.Errorf("Sequences must not contain nil (index "+
				"%d was nil)", i)
		}
		ortValues[i] = v.GetInternals().ortValue
	}

	var sequence * /*line :686:16*/_Ctype_OrtValue /*line :686:26*/
	status := func() *_Ctype_struct_OrtStatus{ _cgoBase0 := /*line :687:29*/&(ortValues[0]); _cgo0 := _cgoBase0; var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :687:54*/(length); var _cgo2 uint32 = /*line :688:3*/_Ciconst_ONNX_TYPE_SEQUENCE /*line :688:23*/; _cgoBase3 := /*line :688:25*/&sequence; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :688:35*/_Cfunc_CreateOrtValue(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if status != nil {
		return nil, fmt.Errorf("Error creating ORT sequence: %s",
			statusToError(status))
	}

	// Finally, we want to get each OrtValue from the sequence itself, but we
	// already have a function to do this in the case of onnxruntime-allocated
	// sequences.
	toReturn, e := createSequenceFromOrtValue(sequence)
	if e != nil {
		// createSequenceFromOrtValue destroys the sequence on error.
		return nil, fmt.Errorf("Error creating go Sequence from sequence "+
			"OrtValue: %w", e)
	}
	return toReturn, nil
}

// Returns the list of values in the sequence. Each of these values should
// _not_ be Destroy()'ed by the caller, they will be automatically destroyed
// upon calling Destroy() on the sequence. If this sequence was created via
// NewSequence, these are not the same Values that the sequence was created
// with, though if they are tensors they should still refer to the same
// underlying data.
func (s *Sequence) GetValues() ([]Value, error) {
	return s.contents, nil
}

func (s *Sequence) Destroy() error {
	func() { _cgo0 := /*line :717:20*/s.ortValue; _cgoCheckPointer(_cgo0, nil); /*line :717:31*/_Cfunc_ReleaseOrtValue(_cgo0); }()
	var e error
	for _, v := range s.contents {
		if v != nil {
			// Just return the last error if any of these returns an error.
			e2 := v.Destroy()
			if e2 != nil {
				e = e2
			}
		}
	}
	s.ortValue = nil
	s.contents = nil
	return e
}

// This returns a 1-dimensional Shape containing a single element: the number
// of elements the sequence. Typically, Sequence users should prefer calling
// len(s.GetValues()) over this function. This function only exists to maintain
// compatibility with the Value interface.
func (s *Sequence) GetShape() Shape {
	return NewShape(int64(len(s.contents)))
}

// Always returns ONNXTypeSequence
func (s *Sequence) GetONNXType() ONNXType {
	return ONNXTypeSequence
}

// This function is meaningless for a Sequence and shouldn't be used. The
// return value is always TENSOR_ELEMENT_DATA_TYPE_UNDEFINED for now, but this
// may change in the future. This function is only present for compatibility
// with the Value interface and should not be relied on for sequences.
func (s *Sequence) DataType()  /*line :750:31*/_Ctype_ONNXTensorElementDataType /*line :750:58*/ {
	return ( /*line :751:9*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED /*line :751:49*/)
}

// This function does nothing for a Sequence, and is only present for
// compatibility with the Value interface.
func (s *Sequence) ZeroContents() {
}

func (s *Sequence) GetInternals() *ValueInternalData {
	return &ValueInternalData{
		ortValue: s.ortValue,
	}
}

// This wraps an ONNX_TYPE_MAP OrtValue. Satisfies the Value interface,
// though Tensor-related functions such as ZeroContents() may be no-ops.
type Map struct {
	ortValue * /*line :768:12*/_Ctype_OrtValue /*line :768:22*/
	// An onnxruntime map is really just two tensors, keys and values, that
	// must be the same length. These Values will be cleaned up when calling
	// Map.Destroy.
	keys   Value
	values Value
}

// Creates a new ONNX map that maps the given keys tensor to the given values
// tensor. Destroying the Map created by this function does _not_ destroy these
// keys and values tensors; the caller is still responsible for destroying
// them.
//
// Internally, creating a Map requires two tensors of the same length, and
// with constraints on type.  For example, keys are not allowed to be floats
// (at least currently). (At the time of writing, this has only been confirmed
// to work with int64 keys.) There may be many other constraints enforced by
// the underlying C API.
func NewMap(keys, values Value) (*Map, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}

	newMapArgs := []* /*line :791:19*/_Ctype_OrtValue /*line :791:29*/{
		keys.GetInternals().ortValue,
		values.GetInternals().ortValue,
	}
	var result * /*line :795:14*/_Ctype_OrtValue /*line :795:24*/
	status := func() *_Ctype_struct_OrtStatus{ _cgoBase0 := /*line :796:29*/&(newMapArgs[0]); _cgo0 := _cgoBase0; var _cgo1 _Ctype_size_t = /*line :796:47*/2; var _cgo2 uint32 = /*line :796:50*/_Ciconst_ONNX_TYPE_MAP /*line :796:65*/; _cgoBase3 := /*line :796:67*/&result; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :796:75*/_Cfunc_CreateOrtValue(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if status != nil {
		return nil, fmt.Errorf("Error creating ORT map: %s",
			statusToError(status))
	}

	// We need to obtain internal references to the keys and values allocated
	// by onnxruntime. createMapFromOrtValue does this for us.
	toReturn, e := createMapFromOrtValue(result)
	if e != nil {
		// createMapFromOrtValue already destroys the OrtValue on error.
		return nil, fmt.Errorf("Error creating Map instance from map "+
			"OrtValue: %w", e)
	}
	return toReturn, nil
}

// Wraps the creation of an ONNX map from a Go map. K is the key type, and V is
// the value type. Be aware that constraints on these types exist based on
// what ONNX supports. See the comment on NewMap.
func NewMapFromGoMap[K, V TensorData](m map[K]V) (*Map, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	keysSlice := make([]K, len(m))
	valuesSlice := make([]V, len(m))
	i := 0
	for k, v := range m {
		keysSlice[i] = k
		valuesSlice[i] = v
		i++
	}
	tensorShape := NewShape(int64(len(m)))
	keysTensor, e := NewTensor(tensorShape, keysSlice)
	if e != nil {
		return nil, fmt.Errorf("Error creating keys tensor for map: %w", e)
	}
	defer keysTensor.Destroy()
	valuesTensor, e := NewTensor(tensorShape, valuesSlice)
	if e != nil {
		return nil, fmt.Errorf("Error creating values tensor for map: %w", e)
	}
	defer valuesTensor.Destroy()
	toReturn, e := NewMap(keysTensor, valuesTensor)
	if e != nil {
		return nil, fmt.Errorf("Error creating map from key and value "+
			"tensors: %w", e)
	}
	return toReturn, nil
}

// Returns two Tensors containing the keys and values, respectively. These
// tensors should _not_ be Destroyed by users; they will be automatically
// cleaned up when m.Destroy() is called. These are _not_ the same Value
// instances that were passed to NewMap, and these should not be modified by
// users.
func (m *Map) GetKeysAndValues() (Value, Value, error) {
	return m.keys, m.values, nil
}

func (m *Map) Destroy() error {
	func() { _cgo0 := /*line :857:20*/m.ortValue; _cgoCheckPointer(_cgo0, nil); /*line :857:31*/_Cfunc_ReleaseOrtValue(_cgo0); }()
	// Just return the last error if either of these returns an error.
	var e error
	e2 := m.keys.Destroy()
	if e2 != nil {
		e = e2
	}
	e2 = m.values.Destroy()
	if e2 != nil {
		e = e2
	}
	m.ortValue = nil
	m.keys = nil
	m.values = nil
	return e
}

// Always returns ONNXTypeMap
func (m *Map) GetONNXType() ONNXType {
	return ONNXTypeMap
}

// Returns the shape of the map's keys Tensor. Essentially, this can be used
// to determine the number of key/value pairs in the map.
func (m *Map) GetShape() Shape {
	return m.keys.GetShape()
}

func (m *Map) GetInternals() *ValueInternalData {
	return &ValueInternalData{
		ortValue: m.ortValue,
	}
}

// As with Sequence.ZeroContents(), this is a no-op (at least for now), and is
// only present for compatibility with the Value interface.
func (m *Map) ZeroContents() {
}

// As with a Sequence, this always returns the undefined data type and is only
// present for compatibility with the Value interface.
func (m *Map) DataType()  /*line :898:26*/_Ctype_ONNXTensorElementDataType /*line :898:53*/ {
	return ( /*line :899:9*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED /*line :899:49*/)
}

// Wraps the ONNXType enum in C.
type ONNXType int

const (
	ONNXTypeUnknown      = ( /*line :906:25*/_Ciconst_ONNX_TYPE_UNKNOWN /*line :906:43*/)
	ONNXTypeTensor       = ( /*line :907:25*/_Ciconst_ONNX_TYPE_TENSOR /*line :907:42*/)
	ONNXTypeSequence     = ( /*line :908:25*/_Ciconst_ONNX_TYPE_SEQUENCE /*line :908:44*/)
	ONNXTypeMap          = ( /*line :909:25*/_Ciconst_ONNX_TYPE_MAP /*line :909:39*/)
	ONNXTypeOpaque       = ( /*line :910:25*/_Ciconst_ONNX_TYPE_OPAQUE /*line :910:42*/)
	ONNXTypeSparseTensor = ( /*line :911:25*/_Ciconst_ONNX_TYPE_SPARSETENSOR /*line :911:48*/)
	ONNXTypeOptional     = ( /*line :912:25*/_Ciconst_ONNX_TYPE_OPTIONAL /*line :912:44*/)
)

func (t ONNXType) String() string {
	switch t {
	case ONNXTypeUnknown:
		return "ONNX_TYPE_UNKNOWN"
	case ONNXTypeTensor:
		return "ONNX_TYPE_TENSOR"
	case ONNXTypeSequence:
		return "ONNX_TYPE_SEQUENCE"
	case ONNXTypeMap:
		return "ONNX_TYPE_MAP"
	case ONNXTypeOpaque:
		return "ONNX_TYPE_OPAQUE"
	case ONNXTypeSparseTensor:
		return "ONNX_TYPE_SPARSE_TENSOR"
	case ONNXTypeOptional:
		return "ONNX_TYPE_OPTIONAL"
	}
	return fmt.Sprintf("Unknown ONNX type: %d", int(t))
}

// This satisfies the Value interface, but is intended to allow users to
// provide tensors of types that may not be supported by the generic typed
// Tensor[T] struct. Instead, CustomDataTensors are backed by a slice of bytes,
// using a user-provided shape and type from the ONNXTensorElementDataType
// enum.
type CustomDataTensor struct {
	data     []byte
	dataType  /*line :942:11*/_Ctype_ONNXTensorElementDataType /*line :942:38*/
	shape    Shape
	ortValue * /*line :944:12*/_Ctype_OrtValue /*line :944:22*/
}

// Creates and returns a new CustomDataTensor using the given bytes as the
// underlying data slice. Apart from ensuring that the provided data slice is
// non-empty, this function mostly delegates validation of the provided data to
// the C onnxruntime library. For example, it is the caller's responsibility to
// ensure that the provided dataType and data slice are valid and correctly
// sized for the specified shape. If this returns successfully, the caller must
// call the returned tensor's Destroy() function to free it when no longer in
// use.
func NewCustomDataTensor(s Shape, data []byte,
	dataType TensorElementDataType) (*CustomDataTensor, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	e := s.Validate()
	if e != nil {
		return nil, fmt.Errorf("Invalid tensor shape: %w", e)
	}
	if len(data) == 0 {
		return nil, fmt.Errorf("A CustomDataTensor requires at least one " +
			"byte of data")
	}
	dt :=  /*line :968:8*/_Ctype_ONNXTensorElementDataType /*line :968:35*/(dataType)
	var ortValue * /*line :969:16*/_Ctype_OrtValue /*line :969:26*/

	status := func() *_Ctype_struct_OrtStatus{ _cgoIndex0 := &/*line :971:55*/data; _cgo0 := /*line :971:39*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :972:11*/(len(data)); var _cgo2 *_Ctype_int64_t = /*line :972:24*/(*_Ctype_int64_t /*line :972:35*/)(unsafe.Pointer(&s[0])); var _cgo3 _Ctype_int64_t = _Ctype_int64_t /*line :973:12*/(len(s)); _cgo4 := /*line :973:22*/ortMemoryInfo; var _cgo5 _Ctype_ONNXTensorElementDataType = /*line :973:37*/dt; _cgoBase6 := /*line :973:41*/&ortValue; _cgo6 := _cgoBase6; _cgoCheckPointer(_cgo0, *_cgoIndex0); _cgoCheckPointer(_cgo4, nil); _cgoCheckPointer(_cgoBase6, 0 == 0); return /*line :973:51*/_Cfunc_CreateOrtTensorWithShape(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	if status != nil {
		return nil, fmt.Errorf("ORT API error creating tensor: %s",
			statusToError(status))
	}
	toReturn := CustomDataTensor{
		data:     data,
		dataType: dt,
		shape:    s.Clone(),
		ortValue: ortValue,
	}
	return &toReturn, nil
}

func (t *CustomDataTensor) Destroy() error {
	func() { _cgo0 := /*line :988:20*/t.ortValue; _cgoCheckPointer(_cgo0, nil); /*line :988:31*/_Cfunc_ReleaseOrtValue(_cgo0); }()
	t.ortValue = nil
	t.data = nil
	t.shape = nil
	t.dataType = ( /*line :992:15*/_Ciconst_ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED /*line :992:55*/)
	return nil
}

func (t *CustomDataTensor) DataType()  /*line :996:39*/_Ctype_ONNXTensorElementDataType /*line :996:66*/ {
	return t.dataType
}

func (t *CustomDataTensor) GetShape() Shape {
	return t.shape.Clone()
}

func (t *CustomDataTensor) GetInternals() *ValueInternalData {
	return &ValueInternalData{
		ortValue: t.ortValue,
	}
}

// Always returns ONNXTypeTensor, even if the CustomDataTensor is invalid for
// some reason.
func (t *CustomDataTensor) GetONNXType() ONNXType {
	return ONNXTypeTensor
}

// Sets all bytes in the data slice to 0.
func (t *CustomDataTensor) ZeroContents() {
	if len(t.data) == 0 {
		return
	}
	func() _cgo_unsafe.Pointer{ _cgoIndex0 := &/*line :1021:27*/t.data; _cgo0 := /*line :1021:11*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :1021:39*/0; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :1021:50*/(len(t.data)); _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :1021:64*/_Cfunc_memset(_cgo0, _cgo1, _cgo2); }()
}

// Returns the same slice that was passed to NewCustomDataTensor.
func (t *CustomDataTensor) GetData() []byte {
	return t.data
}

// Scalar is like a tensor but the underlying go slice is of length 1 and it
// has no dimension. It was introduced for use with the training API, but
// remains supported since it may be useful apart from the training API.
type Scalar[T TensorData] struct {
	data     []T
	dataSize uintptr
	ortValue * /*line :1035:12*/_Ctype_OrtValue /*line :1035:22*/
}

// Always returns nil for Scalars.
func (s *Scalar[T]) GetShape() Shape {
	return nil
}

func (s *Scalar[T]) ZeroContents() {
	func() _cgo_unsafe.Pointer{ _cgoIndex0 := &/*line :1044:27*/s.data; _cgo0 := /*line :1044:11*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :1044:39*/0; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :1044:50*/(s.dataSize); _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :1044:63*/_Cfunc_memset(_cgo0, _cgo1, _cgo2); }()
}

func (s *Scalar[T]) Destroy() error {
	func() { _cgo0 := /*line :1048:20*/s.ortValue; _cgoCheckPointer(_cgo0, nil); /*line :1048:31*/_Cfunc_ReleaseOrtValue(_cgo0); }()
	s.ortValue = nil
	s.data = nil
	s.dataSize = 0
	return nil
}

// GetData returns the undelying data for the scalar. If you want to set the
// scalar's data, use Set.
func (t *Scalar[T]) GetData() T {
	return t.data[0]
}

// Changes the underlying value of the scalar to the new value.
func (t *Scalar[T]) Set(value T) {
	t.data = []T{value}
}

func (t *Scalar[T]) DataType()  /*line :1066:32*/_Ctype_ONNXTensorElementDataType /*line :1066:59*/ {
	return GetTensorElementDataType[T]()
}

func (t *Scalar[_]) GetInternals() *ValueInternalData {
	return &ValueInternalData{
		ortValue: t.ortValue,
	}
}

func (t *Scalar[_]) GetONNXType() ONNXType {
	return ONNXTypeTensor
}

// NewEmptyScalar creates a new scalar of type T.
func NewEmptyScalar[T TensorData]() (*Scalar[T], error) {
	var data T
	return NewScalar(data)
}

// NewScalar creates a new scalar of type T backed by a value of type T.
// Note that, differently from tensors, this is not a []T but just a value T.
func NewScalar[T TensorData](data T) (*Scalar[T], error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}

	dataSlice := []T{data}
	var ortValue * /*line :1094:16*/_Ctype_OrtValue /*line :1094:26*/
	dataType := GetTensorElementDataType[T]()
	dataSize := unsafe.Sizeof(dataSlice[0]) * uintptr(1)

	status := func() *_Ctype_struct_OrtStatus{ _cgoIndex0 := &/*line :1098:55*/dataSlice; _cgo0 := /*line :1098:39*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :1099:11*/(dataSize); var _cgo2 *_Ctype_int64_t = /*line :1099:23*/nil; var _cgo3 _Ctype_int64_t = _Ctype_int64_t /*line :1099:37*/(0); _cgo4 := /*line :1099:42*/ortMemoryInfo; var _cgo5 _Ctype_ONNXTensorElementDataType = /*line :1099:57*/dataType; _cgoBase6 := /*line :1099:67*/&ortValue; _cgo6 := _cgoBase6; _cgoCheckPointer(_cgo0, *_cgoIndex0); _cgoCheckPointer(_cgo4, nil); _cgoCheckPointer(_cgoBase6, 0 == 0); return /*line :1099:77*/_Cfunc_CreateOrtTensorWithShape(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	if status != nil {
		return nil, statusToError(status)
	}
	toReturn := Scalar[T]{
		data:     dataSlice,
		dataSize: dataSize,
		ortValue: ortValue,
	}
	return &toReturn, nil
}

// Holds options required when enabling the CUDA backend for a session. This
// struct wraps C onnxruntime types; users must create instances of this using
// the NewCUDAProviderOptions() function. So, to enable CUDA for a session,
// follow these steps:
//
//  1. Call NewSessionOptions() to create a SessionOptions struct.
//  2. Call NewCUDAProviderOptions() to obtain a CUDAProviderOptions struct.
//  3. Call the CUDAProviderOptions struct's Update(...) function to pass a
//     list of settings to CUDA. (See the comment on the Update() function.)
//  4. Pass the CUDA options struct pointer to the
//     SessionOptions.AppendExecutionProviderCUDA(...) function.
//  5. Call the Destroy() function on the CUDA provider options.
//  6. Call NewAdvancedSession(...), passing the SessionOptions struct to it.
//  7. Call the Destroy() function on the SessionOptions struct.
//
// Admittedly, this is a bit of a mess, but that's how it's handled by the C
// API internally. (The onnxruntime python API hides a bunch of this complexity
// using getter and setter functions, for which Go does not have a terse
// equivalent.)
type CUDAProviderOptions struct {
	o * /*line :1131:5*/_Ctype_OrtCUDAProviderOptionsV2 /*line :1131:31*/
}

// Used when setting key-value pair options with certain obnoxious C APIs.
// The entries in each of the returned slices must be freed when they're
// no longer needed.
func mapToCStrings(options map[string]string) ([]* /*line :1137:51*/_Ctype_char /*line :1137:57*/, []* /*line :1137:62*/_Ctype_char /*line :1137:68*/) {
	keys := make([]* /*line :1138:18*/_Ctype_char /*line :1138:24*/, 0, len(options))
	values := make([]* /*line :1139:20*/_Ctype_char /*line :1139:26*/, 0, len(options))
	for k, v := range options {
		keys = append(keys, ( /*line :1141:23*/_Cfunc_CString /*line :1141:31*/)(k))
		values = append(values, ( /*line :1142:27*/_Cfunc_CString /*line :1142:35*/)(v))
	}
	return keys, values
}

// Calls free on each entry in the array of C strings.
func freeCStrings(s []* /*line :1148:24*/_Ctype_char /*line :1148:30*/) {
	for i := range s {
		func() { _cgo0 := /*line :1150:10*/unsafe.Pointer(s[i]); _cgoCheckPointer(_cgo0, nil); /*line :1150:31*/_Cfunc_free(_cgo0); }()
		s[i] = nil
	}
}

// Wraps the call to the UpdateCUDAProviderOptions in the onnxruntime C API.
// Requires a map of string keys to values for configuring the CUDA backend.
// For example, set the key "device_id" to "1" to use GPU 1 rather than 0.
//
// The onnxruntime headers refer users to
// https://onnxruntime.ai/docs/execution-providers/CUDA-ExecutionProvider.html#configuration-options
// for a full list of available keys and values.
func (o *CUDAProviderOptions) Update(options map[string]string) error {
	if len(options) == 0 {
		return nil
	}
	keys, values := mapToCStrings(options)
	defer freeCStrings(keys)
	defer freeCStrings(values)
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1169:40*/o.o; _cgoBase1 := /*line :1169:45*/&(keys[0]); _cgo1 := _cgoBase1; _cgoBase2 := /*line :1169:57*/&(values[0]); _cgo2 := _cgoBase2; var _cgo3 _Ctype_int = _Ctype_int /*line :1170:8*/(len(options)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1170:23*/_Cfunc_UpdateCUDAProviderOptions(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Must be called when the CUDAProviderOptions struct is no longer needed;
// frees internal C-allocated state. Note that the CUDAProviderOptions struct
// can be destroyed as soon as options.AppendExecutionProviderCUDA has been
// called.
func (o *CUDAProviderOptions) Destroy() error {
	if o.o == nil {
		return fmt.Errorf("The CUDAProviderOptions are not initialized")
	}
	func() { _cgo0 := /*line :1185:31*/o.o; _cgoCheckPointer(_cgo0, nil); /*line :1185:35*/_Cfunc_ReleaseCUDAProviderOptions(_cgo0); }()
	o.o = nil
	return nil
}

// Initializes and returns a CUDAProviderOptions struct, used when enabling
// CUDA in a SessionOptions instance. (i.e., a CUDAProviderOptions must be
// configured, then passed to SessionOptions.AppendExecutionProviderCUDA.)
// The caller must call the Destroy() function on the returned struct when it's
// no longer needed.
func NewCUDAProviderOptions() (*CUDAProviderOptions, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	var o * /*line :1199:9*/_Ctype_OrtCUDAProviderOptionsV2 /*line :1199:35*/
	status := func() *_Ctype_struct_OrtStatus{ _cgoBase0 := /*line :1200:40*/&o; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :1200:43*/_Cfunc_CreateCUDAProviderOptions(_cgo0); }()
	if status != nil {
		return nil, statusToError(status)
	}
	return &CUDAProviderOptions{
		o: o,
	}, nil
}

// Like the CUDAProviderOptions struct, but used for configuring TensorRT
// options. Instances of this struct must be initialized using
// NewTensorRTProviderOptions() and cleaned up by calling their Destroy()
// function when they are no longer needed.
type TensorRTProviderOptions struct {
	o * /*line :1214:5*/_Ctype_OrtTensorRTProviderOptionsV2 /*line :1214:35*/
}

// Wraps the call to the UpdateTensorRTProviderOptions in the C API. Requires
// a map of string keys to values.
//
// The onnxruntime headers refer users to
// https://onnxruntime.ai/docs/execution-providers/TensorRT-ExecutionProvider.html#cc
// for the list of available keys and values.
func (o *TensorRTProviderOptions) Update(options map[string]string) error {
	if len(options) == 0 {
		return nil
	}
	keys, values := mapToCStrings(options)
	defer freeCStrings(keys)
	defer freeCStrings(values)
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1230:44*/o.o; _cgoBase1 := /*line :1230:49*/&(keys[0]); _cgo1 := _cgoBase1; _cgoBase2 := /*line :1230:61*/&(values[0]); _cgo2 := _cgoBase2; var _cgo3 _Ctype_int = _Ctype_int /*line :1231:8*/(len(options)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1231:23*/_Cfunc_UpdateTensorRTProviderOptions(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Must be called when the TensorRTProviderOptions are no longer needed, in
// order to free internal state. The struct is not needed as soon as you have
// passed it to the AppendExecutionProviderTensorRT function.
func (o *TensorRTProviderOptions) Destroy() error {
	if o.o == nil {
		return fmt.Errorf("The TensorRTProviderOptions are not initialized")
	}
	func() { _cgo0 := /*line :1245:35*/o.o; _cgoCheckPointer(_cgo0, nil); /*line :1245:39*/_Cfunc_ReleaseTensorRTProviderOptions(_cgo0); }()
	o.o = nil
	return nil
}

// Initializes and returns a TensorRTProviderOptions struct, used when enabling
// the TensorRT backend. The caller must call the Destroy() function on the
// returned struct when it's no longer needed.
func NewTensorRTProviderOptions() (*TensorRTProviderOptions, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	var o * /*line :1257:9*/_Ctype_OrtTensorRTProviderOptionsV2 /*line :1257:39*/
	status := func() *_Ctype_struct_OrtStatus{ _cgoBase0 := /*line :1258:44*/&o; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :1258:47*/_Cfunc_CreateTensorRTProviderOptions(_cgo0); }()
	if status != nil {
		return nil, statusToError(status)
	}
	return &TensorRTProviderOptions{
		o: o,
	}, nil
}

// Wraps the ExecutionMode enum in C.
type ExecutionMode int

const (
	ExecutionModeSequential = ( /*line :1271:28*/_Ciconst_ORT_SEQUENTIAL /*line :1271:43*/)
	ExecutionModeParallel   = ( /*line :1272:28*/_Ciconst_ORT_PARALLEL /*line :1272:41*/)
)

func (m ExecutionMode) String() string {
	switch m {
	case ExecutionModeSequential:
		return "ORT_SEQUENTIAL"
	case ExecutionModeParallel:
		return "ORT_PARALLEL"
	}
	return fmt.Sprintf("Invalid/unknown execution mode: %d", int(m))
}

// Used to set options when creating an ONNXRuntime session. There is currently
// not a way to change options after the session is created, apart from
// destroying the session and creating a new one. This struct opaquely wraps a
// C OrtSessionOptions struct, which users must modify via function calls. (The
// OrtSessionOptions struct is opaque in the C API, too.)
//
// Users must instantiate this struct using the NewSessionOptions function.
// Instances must be destroyed by calling the Destroy() method after the
// options are no longer needed (after NewAdvancedSession(...) has returned).
type SessionOptions struct {
	o * /*line :1295:5*/_Ctype_OrtSessionOptions /*line :1295:24*/
}

func (o *SessionOptions) Destroy() error {
	if o.o == nil {
		return fmt.Errorf("The SessionOptions are not initialized")
	}
	func() { _cgo0 := /*line :1302:26*/o.o; _cgoCheckPointer(_cgo0, nil); /*line :1302:30*/_Cfunc_ReleaseSessionOptions(_cgo0); }()
	o.o = nil
	return nil
}

// Sets the session's execution mode. The newMode must be
// ExecutionModeSequential or ExecutionModeParallel.
func (o *SessionOptions) SetExecutionMode(newMode ExecutionMode) error {
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1310:38*/o.o; var _cgo1 _Ctype_int = _Ctype_int /*line :1310:48*/(newMode); _cgoCheckPointer(_cgo0, nil); return /*line :1310:58*/_Cfunc_SetSessionExecutionMode(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Sets the optimization level to apply when loading a graph. Refer to
// the C API documentation for SetSessionGraphOptimizationLevel.
func (o *SessionOptions) SetGraphOptimizationLevel(
	level GraphOptimizationLevel) error {
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1321:47*/o.o; var _cgo1 _Ctype_int = _Ctype_int /*line :1321:57*/(level); _cgoCheckPointer(_cgo0, nil); return /*line :1321:65*/_Cfunc_SetSessionGraphOptimizationLevel(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Sets the sessions log severity level. Must be one of LoggingLevelVerbose,
// LoggingLevelInfo, LoggingLevelWarning, LoggingLevelError, or
// LoggingLevelFatal.
func (o *SessionOptions) SetLogSeverityLevel(level LoggingLevel) error {
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1332:41*/o.o; var _cgo1 _Ctype_int = _Ctype_int /*line :1332:51*/(level); _cgoCheckPointer(_cgo0, nil); return /*line :1332:59*/_Cfunc_SetSessionLogSeverityLevel(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Returns true, nil if the SessionOptions has a configuration entry with the
// given key. Returns false if the key isn't defined. Returns an error if
// onnxruntime indicates an error, though it isn't clear from the docs what
// may cause an error to occur here. See also GetSessionConfigEntry and
// AddSessionConfigEntry.
func (o *SessionOptions) HasSessionConfigEntry(key string) (bool, error) {
	cKey := ( /*line :1345:10*/_Cfunc_CString /*line :1345:18*/)(key)
	defer func() func() { _cgo0 := /*line :1346:15*/unsafe.Pointer(cKey); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1346:36*/_Cfunc_free(_cgo0); }}()()
	var out  /*line :1347:10*/_Ctype_int /*line :1347:15*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1348:36*/o.o; var _cgo1 *_Ctype_char = /*line :1348:41*/cKey; var _cgo2 *_Ctype_int = /*line :1348:47*/&out; _cgoCheckPointer(_cgo0, nil); return /*line :1348:52*/_Cfunc_HasSessionConfigEntry(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return false, statusToError(status)
	}
	return out != 0, nil
}

// Returns the session config entry corresponding to the given key, or an error
// if one occurs. Returns an error if the key doesn't exist, so it may be
// cheaper to check for the key with HasSessionConfigEntry first. See also
// AddSessionConfigEntry.
func (o *SessionOptions) GetSessionConfigEntry(key string) (string, error) {
	var neededSize  /*line :1360:17*/_Ctype_size_t /*line :1360:25*/
	cKey := ( /*line :1361:10*/_Cfunc_CString /*line :1361:18*/)(key)
	defer func() func() { _cgo0 := /*line :1362:15*/unsafe.Pointer(cKey); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1362:36*/_Cfunc_free(_cgo0); }}()()
	// First check for the size of the key. (This includes the null terminator)
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1364:36*/o.o; var _cgo1 *_Ctype_char = /*line :1364:41*/cKey; var _cgo2 *_Ctype_char = /*line :1364:47*/nil; var _cgo3 *_Ctype_size_t = /*line :1364:52*/&neededSize; _cgoCheckPointer(_cgo0, nil); return /*line :1364:64*/_Cfunc_GetSessionConfigEntry(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if status != nil {
		return "", fmt.Errorf("Error determining size of key %s: %w", key,
			statusToError(status))
	}
	// Should catch the case if the entry was an empty string.
	if neededSize <= 1 {
		return "", nil
	}

	// We'll allocate the buffer to hold the string in Go to keep the C simpler
	resultBuffer := make([] /*line :1375:25*/_Ctype_char /*line :1375:31*/, neededSize)
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1376:35*/o.o; var _cgo1 *_Ctype_char = /*line :1376:40*/cKey; var _cgo2 *_Ctype_char = /*line :1376:46*/&(resultBuffer[0]); var _cgo3 *_Ctype_size_t = /*line :1377:3*/&neededSize; _cgoCheckPointer(_cgo0, nil); return /*line :1377:15*/_Cfunc_GetSessionConfigEntry(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if status != nil {
		return "", fmt.Errorf("Error getting contents of key %s: %w", key,
			statusToError(status))
	}
	toReturn := ( /*line :1382:14*/_Cfunc_GoString /*line :1382:23*/)(&(resultBuffer[0]))
	return toReturn, nil
}

// Sets a session configuration key to the given value. See the
// onnxruntime_session_options_config_keys.h file in the onnxruntime sources
// for documentation on valid keys and values. If the key was already set, this
// will overwrite its old setting with the given value.
func (o *SessionOptions) AddSessionConfigEntry(key, value string) error {
	cKey := ( /*line :1391:10*/_Cfunc_CString /*line :1391:18*/)(key)
	defer func() func() { _cgo0 := /*line :1392:15*/unsafe.Pointer(cKey); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1392:36*/_Cfunc_free(_cgo0); }}()()
	cValue := ( /*line :1393:12*/_Cfunc_CString /*line :1393:20*/)(value)
	defer func() func() { _cgo0 := /*line :1394:15*/unsafe.Pointer(cValue); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1394:38*/_Cfunc_free(_cgo0); }}()()
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1395:36*/o.o; var _cgo1 *_Ctype_char = /*line :1395:41*/cKey; var _cgo2 *_Ctype_char = /*line :1395:47*/cValue; _cgoCheckPointer(_cgo0, nil); return /*line :1395:54*/_Cfunc_AddSessionConfigEntry(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Sets the number of threads used to parallelize execution within onnxruntime
// graph nodes. A value of 0 uses the default number of threads.
func (o *SessionOptions) SetIntraOpNumThreads(n int) error {
	if n < 0 {
		return fmt.Errorf("Number of threads must be at least 0, got %d", n)
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1408:35*/o.o; var _cgo1 _Ctype_int = _Ctype_int /*line :1408:45*/(n); _cgoCheckPointer(_cgo0, nil); return /*line :1408:49*/_Cfunc_SetIntraOpNumThreads(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Sets the number of threads used to parallelize execution across separate
// onnxruntime graph nodes. A value of 0 uses the default number of threads.
func (o *SessionOptions) SetInterOpNumThreads(n int) error {
	if n < 0 {
		return fmt.Errorf("Number of threads must be at least 0, got %d", n)
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1421:35*/o.o; var _cgo1 _Ctype_int = _Ctype_int /*line :1421:45*/(n); _cgoCheckPointer(_cgo0, nil); return /*line :1421:49*/_Cfunc_SetInterOpNumThreads(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Enable/Disable the usage of the memory arena on CPU.
// Arena may pre-allocate memory for future usage.
func (o *SessionOptions) SetCpuMemArena(isEnabled bool) error {
	n := 0
	if isEnabled {
		n = 1
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1435:29*/o.o; var _cgo1 _Ctype_int = _Ctype_int /*line :1435:39*/(n); _cgoCheckPointer(_cgo0, nil); return /*line :1435:43*/_Cfunc_SetCpuMemArena(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Enable/Disable the memory pattern optimization.
// If this is enabled memory is preallocated if all shapes are known.
func (o *SessionOptions) SetMemPattern(isEnabled bool) error {
	n := 0
	if isEnabled {
		n = 1
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1449:28*/o.o; var _cgo1 _Ctype_int = _Ctype_int /*line :1449:38*/(n); _cgoCheckPointer(_cgo0, nil); return /*line :1449:42*/_Cfunc_SetMemPattern(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Takes a pointer to an initialized CUDAProviderOptions instance, and applies
// them to the session options. This is what you'll need to call if you want
// the session to use CUDA. Returns an error if your device (or onnxruntime
// library) does not support CUDA. The CUDAProviderOptions struct can be
// destroyed after this.
func (o *SessionOptions) AppendExecutionProviderCUDA(
	cudaOptions *CUDAProviderOptions) error {
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1463:44*/o.o; _cgo1 := /*line :1463:49*/cudaOptions.o; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :1463:63*/_Cfunc_AppendExecutionProviderCUDAV2(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Takes an initialized TensorRTProviderOptions instance, and applies them to
// the session options. You'll need to call this if you want the session to use
// TensorRT. Returns an error if your device (or onnxruntime library version)
// does not support TensorRT. The TensorRTProviderOptions can be destroyed
// after this.
func (o *SessionOptions) AppendExecutionProviderTensorRT(
	tensorRTOptions *TensorRTProviderOptions) error {
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1477:48*/o.o; _cgo1 := /*line :1477:53*/tensorRTOptions.o; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :1477:71*/_Cfunc_AppendExecutionProviderTensorRTV2(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Enables the CoreML backend for the given session options on supported
// platforms.
// The meanings of the flag bits are currently defined in the
// coreml_provider_factory.h file which is provided in the include/ directory of
// the onnxruntime releases for Apple platforms.
// AppendExecutionProviderCoreML is now deprecated. Please use AppendExecutionProviderCoreMLV2 instead.
// See: https://onnxruntime.ai/docs/execution-providers/CoreML-ExecutionProvider.html
func (o *SessionOptions) AppendExecutionProviderCoreML(flags uint32) error {
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1492:44*/o.o; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :1492:59*/(flags); _cgoCheckPointer(_cgo0, nil); return /*line :1492:67*/_Cfunc_AppendExecutionProviderCoreML(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// AppendExecutionProviderCoreMLV2 is the new API for adding CoreML provider to ONNX Runtime.
// This is the recommended way to add CoreML provider as of ONNX Runtime 1.20.0.
//
// For CoreML options, see:
// https://onnxruntime.ai/docs/execution-providers/CoreML-ExecutionProvider.html
func (o *SessionOptions) AppendExecutionProviderCoreMLV2(options map[string]string) error {

	// Handle case with no options
	if len(options) == 0 {
		status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1508:47*/o.o; var _cgo1 **_Ctype_char = /*line :1508:52*/nil; var _cgo2 **_Ctype_char = /*line :1508:57*/nil; var _cgo3 _Ctype_size_t = /*line :1508:62*/0; _cgoCheckPointer(_cgo0, nil); return /*line :1508:64*/_Cfunc_AppendExecutionProviderCoreMLV2(_cgo0, _cgo1, _cgo2, _cgo3); }()
		if status != nil {
			return statusToError(status)
		}
		return nil
	}

	// Convert map to arrays of keys and values
	keys, values := mapToCStrings(options)
	defer freeCStrings(keys)
	defer freeCStrings(values)

	// Call C function
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1521:46*/o.o; _cgoIndex1 := &/*line :1522:4*/keys; _cgo1 := /*line :1522:3*/&(*_cgoIndex1)[0]; _cgoIndex2 := &/*line :1522:14*/values; _cgo2 := /*line :1522:13*/&(*_cgoIndex2)[0]; var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :1522:33*/(len(options)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo2, *_cgoIndex2); return /*line :1522:48*/_Cfunc_AppendExecutionProviderCoreMLV2(_cgo0, _cgo1, _cgo2, _cgo3); }()

	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Enables the DirectML backend for the given session options on supported
// platforms. See the notes on device_id in coreml_provider_factory.h in the
// onnxruntime source code, but a device ID of 0 should correspond to the
// default device, "which is typically the primary display GPU" according to
// the docs.
func (o *SessionOptions) AppendExecutionProviderDirectML(deviceID int) error {
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1536:46*/o.o; var _cgo1 _Ctype_int = _Ctype_int /*line :1536:56*/(deviceID); _cgoCheckPointer(_cgo0, nil); return /*line :1536:67*/_Cfunc_AppendExecutionProviderDirectML(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Enables the OpenVINO backend for the given session options on supported
// platforms. See
// https://onnxruntime.ai/docs/execution-providers/OpenVINO-ExecutionProvider.html#summary-of-options
// for a list of supported keys and values that can be passed in the options
// map.
func (o *SessionOptions) AppendExecutionProviderOpenVINO(
	options map[string]string) error {
	// There's probably a more concise way to do this, but we don't want to
	// do "&(keys[0])" if keys is an empty slice, so we'll declare the null
	// ptrs ahead of time and only set them if we know the slices aren't empty.
	var keysPtr, valuesPtr ** /*line :1553:27*/_Ctype_char /*line :1553:33*/
	if len(options) != 0 {
		keys, values := mapToCStrings(options)
		defer freeCStrings(keys)
		defer freeCStrings(values)
		keysPtr = &(keys[0])
		valuesPtr = &(values[0])
	}

	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1562:48*/o.o; _cgo1 := /*line :1562:53*/keysPtr; _cgo2 := /*line :1562:62*/valuesPtr; var _cgo3 _Ctype_int = _Ctype_int /*line :1563:8*/(len(options)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return /*line :1563:23*/_Cfunc_AppendExecutionProviderOpenVINOV2(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Wraps the AppendExecutionProvider onnxruntime C API function. See the
// documentation for that function for a list of all names and supported
// options.
func (o *SessionOptions) AppendExecutionProvider(providerName string,
	options map[string]string) error {
	name := ( /*line :1575:10*/_Cfunc_CString /*line :1575:18*/)(providerName)
	defer func() func() { _cgo0 := /*line :1576:15*/unsafe.Pointer(name); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1576:36*/_Cfunc_free(_cgo0); }}()()
	var keysPtr, valuesPtr ** /*line :1577:27*/_Ctype_char /*line :1577:33*/
	if len(options) != 0 {
		keys, values := mapToCStrings(options)
		defer freeCStrings(keys)
		defer freeCStrings(values)
		keysPtr = &(keys[0])
		valuesPtr = &(values[0])
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1585:38*/o.o; var _cgo1 *_Ctype_char = /*line :1585:43*/name; _cgo2 := /*line :1585:49*/keysPtr; _cgo3 := /*line :1585:58*/valuesPtr; var _cgo4 _Ctype_int = _Ctype_int /*line :1586:8*/(len(options)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); return /*line :1586:23*/_Cfunc_AppendExecutionProvider(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Initializes and returns a SessionOptions struct, used when setting options
// in new AdvancedSession instances. The caller must call the Destroy()
// function on the returned struct when it's no longer needed.
func NewSessionOptions() (*SessionOptions, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	var o * /*line :1600:9*/_Ctype_OrtSessionOptions /*line :1600:28*/
	status := func() *_Ctype_struct_OrtStatus{ _cgoBase0 := /*line :1601:35*/&o; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :1601:38*/_Cfunc_CreateSessionOptions(_cgo0); }()
	if status != nil {
		return nil, statusToError(status)
	}
	return &SessionOptions{
		o: o,
	}, nil
}

// RunOptions wraps OrtRunOptions for per-run settings and cancellation.
type RunOptions struct {
	o * /*line :1612:5*/_Ctype_OrtRunOptions /*line :1612:20*/
}

// NewRunOptions creates a new OrtRunOptions instance. Must be closed when no longer needed.
func NewRunOptions() (*RunOptions, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	var o * /*line :1620:9*/_Ctype_OrtRunOptions /*line :1620:24*/
	status := func() *_Ctype_struct_OrtStatus{ _cgoBase0 := /*line :1621:31*/&o; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :1621:34*/_Cfunc_CreateRunOptions(_cgo0); }()
	if status != nil {
		return nil, statusToError(status)
	}
	return &RunOptions{o: o}, nil
}

// Destroy releases the underlying OrtRunOptions.
func (o *RunOptions) Destroy() error {
	if o == nil || o.o == nil {
		return fmt.Errorf("The RunOptions are not initialized")
	}
	func() { _cgo0 := /*line :1633:22*/o.o; _cgoCheckPointer(_cgo0, nil); /*line :1633:26*/_Cfunc_ReleaseRunOptions(_cgo0); }()
	o.o = nil
	return nil
}

// Terminate sets the terminate flag so any ongoing Run using this RunOptions fails quickly.
func (o *RunOptions) Terminate() error {
	if o == nil || o.o == nil {
		return fmt.Errorf("The RunOptions are not initialized")
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1643:37*/o.o; _cgoCheckPointer(_cgo0, nil); return /*line :1643:41*/_Cfunc_RunOptionsSetTerminate(_cgo0); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// UnsetTerminate clears the terminate flag so this RunOptions can be reused.
func (o *RunOptions) UnsetTerminate() error {
	if o == nil || o.o == nil {
		return fmt.Errorf("The RunOptions are not initialized")
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1655:39*/o.o; _cgoCheckPointer(_cgo0, nil); return /*line :1655:43*/_Cfunc_RunOptionsUnsetTerminate(_cgo0); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// A wrapper around the OrtModelMetadata C struct. Must be freed by calling
// Destroy() on it when it's no longer needed.
type ModelMetadata struct {
	m * /*line :1665:5*/_Ctype_OrtModelMetadata /*line :1665:23*/
}

// Frees internal state required by the model metadata. Users are responsible
// for calling this on any ModelMetadata instance after it's no longer needed.
func (m *ModelMetadata) Destroy() error {
	if m.m != nil {
		func() { _cgo0 := /*line :1672:26*/m.m; _cgoCheckPointer(_cgo0, nil); /*line :1672:30*/_Cfunc_ReleaseModelMetadata(_cgo0); }()
		m.m = nil
	}
	return nil
}

// Takes a C string allocated using the default ORT allocator, converts it to
// a Go string, and frees the C copy. Returns an error if one occurs. Returns
// an empty string with no error if s is nil. Obviously, s is invalid after
// this returns.
func convertORTString(s * /*line :1682:26*/_Ctype_char /*line :1682:32*/) (string, error) {
	if s == nil {
		return "", nil
	}
	// Unfortunately, onnxruntime wants to use custom allocators to allocate
	// data such as strings, which are rather obtuse to customize. Therefore,
	// our C code always specifies the default ORT allocator when possible. We
	// move any strings ORT allocates into Go strings so we can free the C
	// versions as soon as possible.
	toReturn := ( /*line :1691:14*/_Cfunc_GoString /*line :1691:23*/)(s)
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1692:42*/unsafe.Pointer(s); _cgoCheckPointer(_cgo0, nil); return /*line :1692:60*/_Cfunc_FreeWithDefaultORTAllocator(_cgo0); }()
	if status != nil {
		return toReturn, statusToError(status)
	}
	return toReturn, nil
}

// Returns the producer name associated with the model metadata, or an error if
// the name can't be obtained.
func (m *ModelMetadata) GetProducerName() (string, error) {
	var cName * /*line :1702:13*/_Ctype_char /*line :1702:19*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1703:43*/m.m; _cgoBase1 := /*line :1703:48*/&cName; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1703:55*/_Cfunc_ModelMetadataGetProducerName(_cgo0, _cgo1); }()
	if status != nil {
		return "", statusToError(status)
	}
	return convertORTString(cName)
}

// Returns the graph name associated with the model metadata, or an error if
// the name can't be obtained.
func (m *ModelMetadata) GetGraphName() (string, error) {
	var cName * /*line :1713:13*/_Ctype_char /*line :1713:19*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1714:40*/m.m; _cgoBase1 := /*line :1714:45*/&cName; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1714:52*/_Cfunc_ModelMetadataGetGraphName(_cgo0, _cgo1); }()
	if status != nil {
		return "", statusToError(status)
	}
	return convertORTString(cName)
}

// Returns the domain associated with the model metadata, or an error if the
// domain can't be obtained.
func (m *ModelMetadata) GetDomain() (string, error) {
	var cDomain * /*line :1724:15*/_Ctype_char /*line :1724:21*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1725:37*/m.m; _cgoBase1 := /*line :1725:42*/&cDomain; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1725:51*/_Cfunc_ModelMetadataGetDomain(_cgo0, _cgo1); }()
	if status != nil {
		return "", statusToError(status)
	}
	return convertORTString(cDomain)
}

// Returns the description associated with the model metadata, or an error if
// the description can't be obtained.
func (m *ModelMetadata) GetDescription() (string, error) {
	var cDescription * /*line :1735:20*/_Ctype_char /*line :1735:26*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1736:42*/m.m; _cgoBase1 := /*line :1736:47*/&cDescription; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1736:61*/_Cfunc_ModelMetadataGetDescription(_cgo0, _cgo1); }()
	if status != nil {
		return "", statusToError(status)
	}
	return convertORTString(cDescription)
}

// Returns the version number in the model metadata, or an error if one occurs.
func (m *ModelMetadata) GetVersion() (int64, error) {
	var version  /*line :1745:14*/_Ctype_int64_t /*line :1745:23*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1746:38*/m.m; var _cgo1 *_Ctype_int64_t = /*line :1746:43*/&version; _cgoCheckPointer(_cgo0, nil); return /*line :1746:52*/_Cfunc_ModelMetadataGetVersion(_cgo0, _cgo1); }()
	if status != nil {
		return 0, statusToError(status)
	}
	return int64(version), nil
}

// Looks up and returns the string associated with the given key in the custom
// metadata map. Returns a blank string and 'false' if the key isn't in the
// map. (A key that's in the map but set to a blank string will
// return "" and true instead.)
//
// NOTE: It is unclear from the onnxruntime documentation for this function
// whether an error will be returned if the key isn't present. At the time of
// writing (1.17.1) the docs only state that no value is returned, not whether
// an error occurs.
func (m *ModelMetadata) LookupCustomMetadataMap(key string) (string, bool, error) {
	var cValue * /*line :1763:14*/_Ctype_char /*line :1763:20*/
	cKey := ( /*line :1764:10*/_Cfunc_CString /*line :1764:18*/)(key)
	defer func() func() { _cgo0 := /*line :1765:15*/unsafe.Pointer(cKey); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1765:36*/_Cfunc_free(_cgo0); }}()()
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1766:51*/m.m; var _cgo1 *_Ctype_char = /*line :1766:56*/cKey; _cgoBase2 := /*line :1766:62*/&cValue; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1766:70*/_Cfunc_ModelMetadataLookupCustomMetadataMap(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return "", false, statusToError(status)
	}
	if cValue == nil {
		return "", false, nil
	}
	value, e := convertORTString(cValue)
	return value, true, e
}

// Returns a list of keys that are present in the custom metadata map. Returns
// an empty slice or nil if no keys are in the map.
//
// NOTE: It is unclear from the docs whether an empty custom metadata map will
// cause the underlying C function to return an error along with a NULL list,
// or whether it will only return a NULL list with no error.
func (m *ModelMetadata) GetCustomMetadataMapKeys() ([]string, error) {
	var keyCount  /*line :1784:15*/_Ctype_int64_t /*line :1784:24*/
	var cKeys ** /*line :1785:14*/_Ctype_char /*line :1785:20*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1786:52*/m.m; _cgoBase1 := /*line :1786:57*/&cKeys; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_int64_t = /*line :1786:65*/&keyCount; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1786:75*/_Cfunc_ModelMetadataGetCustomMetadataMapKeys(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return nil, statusToError(status)
	}
	if cKeys == nil {
		// We got no keys in the map and no error return
		return nil, nil
	}
	if keyCount == 0 {
		// We have a non-NULL but empty list of C pointers, so we'll still
		// free it here.
		status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1797:43*/unsafe.Pointer(cKeys); _cgoCheckPointer(_cgo0, nil); return /*line :1797:65*/_Cfunc_FreeWithDefaultORTAllocator(_cgo0); }()
		if status != nil {
			return nil, statusToError(status)
		}
		return nil, nil
	}

	// The slice allows us to index into the array of C-string pointers.
	cKeySlice := unsafe.Slice(cKeys, int64(keyCount))
	toReturn := make([]string, len(cKeySlice))
	var e error
	for i, s := range cKeySlice {
		// We won't check for errors until after the loop, because we want to
		// continue trying to free all of the strings regardless of whether an
		// error occurs for one of them.
		toReturn[i], e = convertORTString(s)
		cKeySlice[i] = nil
	}
	// At this point, we've done our best to convert and free all of the ORT-
	// allocated C strings, but we still need to free the array itself, which
	// we attempt regardless of whether an error occurred during the string
	// processing.
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :1819:41*/unsafe.Pointer(cKeys); _cgoCheckPointer(_cgo0, nil); return /*line :1819:63*/_Cfunc_FreeWithDefaultORTAllocator(_cgo0); }()
	cKeySlice = nil
	cKeys = nil
	if e != nil {
		return nil, fmt.Errorf("Error copying one or more C strings to Go: %w",
			e)
	}
	if status != nil {
		return nil, fmt.Errorf("Error freeing array of C strings: %w",
			statusToError(status))
	}

	return toReturn, nil
}

// A wrapper around the OrtSession C struct. Requires the user to maintain all
// input and output tensors, and to use the same data type for input and output
// tensors. Created using NewAdvancedSession(...) or
// NewAdvancedSessionWithONNXData(...). The caller is responsible for calling
// the Destroy() function on each session when it is no longer needed.
type AdvancedSession struct {
	ortSession * /*line :1840:14*/_Ctype_OrtSession /*line :1840:26*/
	// We convert the tensor names to C strings only once, and keep them around
	// here for future calls to Run().
	inputNames  []* /*line :1843:17*/_Ctype_char /*line :1843:23*/
	outputNames []* /*line :1844:17*/_Ctype_char /*line :1844:23*/
	// We only need the OrtValue pointers from the tensors when working with
	// the C API. Also, these fields aren't used with a DynamicAdvancedSession.
	inputs  []* /*line :1847:13*/_Ctype_OrtValue /*line :1847:23*/
	outputs []* /*line :1848:13*/_Ctype_OrtValue /*line :1848:23*/
}

func createCSession(onnxData []byte, options *SessionOptions) (* /*line :1851:65*/_Ctype_OrtSession /*line :1851:77*/,
	error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	if len(onnxData) == 0 {
		return nil, fmt.Errorf("Missing ONNX data")
	}
	var ortSession * /*line :1859:18*/_Ctype_OrtSession /*line :1859:30*/
	var ortSessionOptions * /*line :1860:25*/_Ctype_OrtSessionOptions /*line :1860:44*/
	if options != nil {
		ortSessionOptions = options.o
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgoBase0 := /*line :1864:43*/&(onnxData[0]); _cgo0 := /*line :1864:28*/unsafe.Pointer(_cgoBase0); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :1865:11*/(len(onnxData)); _cgo2 := /*line :1865:28*/ortEnv; _cgoBase3 := /*line :1865:36*/&ortSession; _cgo3 := _cgoBase3; _cgo4 := /*line :1865:49*/ortSessionOptions; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); _cgoCheckPointer(_cgo4, nil); return /*line :1865:67*/_Cfunc_CreateSession(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if status != nil {
		return nil, statusToError(status)
	}
	return ortSession, nil
}

// Basically identical to createCSession, except uses a file path rather than
// a buffer of .onnx content.
func createCSessionFromFile(path string,
	options *SessionOptions) (* /*line :1875:29*/_Ctype_OrtSession /*line :1875:41*/, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	cPath, e := createOrtCharString(path)
	if e != nil {
		return nil, fmt.Errorf("Unable to convert path to C path: %w", e)
	}
	var ortSession * /*line :1883:18*/_Ctype_OrtSession /*line :1883:30*/
	var ortSessionOptions * /*line :1884:25*/_Ctype_OrtSessionOptions /*line :1884:44*/
	if options != nil {
		ortSessionOptions = options.o
	}
	status := func() *_Ctype_struct_OrtStatus{ var _cgo0 *_Ctype_char = /*line :1888:36*/cPath; _cgo1 := /*line :1888:43*/ortEnv; _cgoBase2 := /*line :1888:51*/&ortSession; _cgo2 := _cgoBase2; _cgo3 := /*line :1889:3*/ortSessionOptions; _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgo3, nil); return /*line :1889:21*/_Cfunc_CreateSessionFromFile(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if status != nil {
		return nil, statusToError(status)
	}
	return ortSession, nil
}

// Initializes an AdvancedSession object without creating the session;
// essentially converting input and output names. Set the dynamicInputs
// argument to true if this will be used for a DynamicAdvancedSession; it will
// skip checks on the inputs and outputs []Values.
func newAdvancedSessionInternal(inputNames, outputNames []string,
	inputs, outputs []Value, dynamicInputs bool) (*AdvancedSession, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	if !dynamicInputs {
		if len(inputs) == 0 {
			return nil, fmt.Errorf("No inputs were provided")
		}
		if len(outputs) == 0 {
			return nil, fmt.Errorf("No outputs were provided")
		}
		if len(inputs) != len(inputNames) {
			return nil, fmt.Errorf("Got %d inputs, but %d input names",
				len(inputs), len(inputNames))
		}
		if len(outputs) != len(outputNames) {
			return nil, fmt.Errorf("Got %d outputs, but %d output names",
				len(outputs), len(outputNames))
		}
	}
	// Collect the inputs and outputs, along with their names, into a format
	// more convenient for passing to the Run() function in the C API.
	cInputNames := make([]* /*line :1923:25*/_Ctype_char /*line :1923:31*/, len(inputNames))
	cOutputNames := make([]* /*line :1924:26*/_Ctype_char /*line :1924:32*/, len(outputNames))
	for i, v := range inputNames {
		cInputNames[i] = ( /*line :1926:20*/_Cfunc_CString /*line :1926:28*/)(v)
	}
	for i, v := range outputNames {
		cOutputNames[i] = ( /*line :1929:21*/_Cfunc_CString /*line :1929:29*/)(v)
	}
	var inputOrtValues, outputOrtValues []* /*line :1931:41*/_Ctype_OrtValue /*line :1931:51*/
	if !dynamicInputs {
		inputOrtValues = make([]* /*line :1933:28*/_Ctype_OrtValue /*line :1933:38*/, len(inputs))
		outputOrtValues = make([]* /*line :1934:29*/_Ctype_OrtValue /*line :1934:39*/, len(outputs))
		for i, v := range inputs {
			inputOrtValues[i] = v.GetInternals().ortValue
		}
		for i, v := range outputs {
			outputOrtValues[i] = v.GetInternals().ortValue
		}
	}
	return &AdvancedSession{
		ortSession:  nil,
		inputNames:  cInputNames,
		outputNames: cOutputNames,
		inputs:      inputOrtValues,
		outputs:     outputOrtValues,
	}, nil
}

// The same as NewAdvancedSession, but takes a slice of bytes containing the
// .onnx network rather than a file path.
func NewAdvancedSessionWithONNXData(onnxData []byte, inputNames,
	outputNames []string, inputs, outputs []Value,
	options *SessionOptions) (*AdvancedSession, error) {
	toReturn, e := newAdvancedSessionInternal(inputNames, outputNames, inputs,
		outputs, false)
	if e != nil {
		return nil, e
	}
	toReturn.ortSession, e = createCSession(onnxData, options)
	if e != nil {
		toReturn.Destroy()
		return nil, fmt.Errorf("Error creating C session: %w", e)
	}
	return toReturn, nil
}

// Loads the ONNX network at the given path, and initializes an AdvancedSession
// instance. If this returns successfully, the caller must call Destroy() on
// the returned session when it is no longer needed. We require the user to
// provide the input and output tensors and names at this point, in order to
// not need to re-allocate them every time Run() is called. The user instead
// can just update or access the input/output tensor data after calling Run().
// The input and output tensors MUST outlive this session, and calling
// session.Destroy() will not destroy the input or output tensors. If the
// provided SessionOptions pointer is nil, then the new session will use
// default options.
func NewAdvancedSession(onnxFilePath string, inputNames, outputNames []string,
	inputs, outputs []Value,
	options *SessionOptions) (*AdvancedSession, error) {
	toReturn, e := newAdvancedSessionInternal(inputNames, outputNames, inputs,
		outputs, false)
	if e != nil {
		return nil, e
	}
	toReturn.ortSession, e = createCSessionFromFile(onnxFilePath, options)
	if e != nil {
		toReturn.Destroy()
		return nil, fmt.Errorf("Error creating C session from file: %w", e)
	}
	return toReturn, nil
}

func (s *AdvancedSession) Destroy() error {
	// Including the check that ortSession is not nil allows the Destroy()
	// function to be used on AdvancedSessions that are partially initialized,
	// which we do internally.
	if s.ortSession != nil {
		func() { _cgo0 := /*line :2000:23*/s.ortSession; _cgoCheckPointer(_cgo0, nil); /*line :2000:36*/_Cfunc_ReleaseOrtSession(_cgo0); }()
		s.ortSession = nil
	}
	for i := range s.inputNames {
		func() { _cgo0 := /*line :2004:10*/unsafe.Pointer(s.inputNames[i]); _cgoCheckPointer(_cgo0, nil); /*line :2004:42*/_Cfunc_free(_cgo0); }()
	}
	s.inputNames = nil
	for i := range s.outputNames {
		func() { _cgo0 := /*line :2008:10*/unsafe.Pointer(s.outputNames[i]); _cgoCheckPointer(_cgo0, nil); /*line :2008:43*/_Cfunc_free(_cgo0); }()
	}
	s.outputNames = nil
	s.inputs = nil
	s.outputs = nil
	return nil
}

// Runs the session, updating the contents of the output tensors on success.
func (s *AdvancedSession) Run() error {
	return s.RunWithOptions(nil)
}

// RunWithOptions runs the session using the provided RunOptions.
func (s *AdvancedSession) RunWithOptions(opts *RunOptions) error {
	var optsPtr * /*line :2023:15*/_Ctype_OrtRunOptions /*line :2023:30*/
	if opts != nil {
		optsPtr = opts.o
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2027:39*/s.ortSession; _cgoIndex1 := &/*line :2027:54*/s.inputs; _cgo1 := /*line :2027:53*/&(*_cgoIndex1)[0]; _cgoIndex2 := &/*line :2027:68*/s.inputNames; _cgo2 := /*line :2027:67*/&(*_cgoIndex2)[0]; var _cgo3 _Ctype_int = _Ctype_int /*line :2028:8*/(len(s.inputs)); _cgoIndex4 := &/*line :2028:26*/s.outputs; _cgo4 := /*line :2028:25*/&(*_cgoIndex4)[0]; _cgoIndex5 := &/*line :2028:41*/s.outputNames; _cgo5 := /*line :2028:40*/&(*_cgoIndex5)[0]; var _cgo6 _Ctype_int = _Ctype_int /*line :2029:8*/(len(s.outputs)); _cgo7 := /*line :2029:26*/optsPtr; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo2, *_cgoIndex2); _cgoCheckPointer(_cgo4, *_cgoIndex4); _cgoCheckPointer(_cgo5, *_cgoIndex5); _cgoCheckPointer(_cgo7, nil); return /*line :2029:34*/_Cfunc_RunOrtSessionWithOptions(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
	if status != nil {
		return fmt.Errorf("Error running network: %w", statusToError(status))
	}
	return nil
}

// Wraps the OrtIoBinding instance. Must be created using
// DynamicAdvancedSession's CreateIoBinding method and Destroy'ed when no
// longer needed. (Only DynamicAdvancedSession is supported for this, since
// a regular AdvancedSession requires specifying input and output tensors at
// session creation time.)
type IoBinding struct {
	o * /*line :2042:5*/_Ctype_OrtIoBinding /*line :2042:19*/
}

// Creates and returns an IoBinding instance associated with the session. The
// I/O binding can be used to avoid unecessary copies to or from device memory,
// for sessions on different devices. The returned IoBinding must be freed
// using Destroy() when it is no longer needed.
func (s *DynamicAdvancedSession) CreateIoBinding() (*IoBinding, error) {
	var o * /*line :2050:9*/_Ctype_OrtIoBinding /*line :2050:23*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2051:30*/s.s.ortSession; _cgoBase1 := /*line :2051:46*/&o; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :2051:49*/_Cfunc_CreateIoBinding(_cgo0, _cgo1); }()
	if status != nil {
		return nil, statusToError(status)
	}
	return &IoBinding{
		o: o,
	}, nil
}

// Must be called to free resources associated with the IoBinding once it's
// no longer needed.
func (b *IoBinding) Destroy() error {
	if b.o != nil {
		func() { _cgo0 := /*line :2064:22*/b.o; _cgoCheckPointer(_cgo0, nil); /*line :2064:26*/_Cfunc_ReleaseIoBinding(_cgo0); }()
		b.o = nil
	}
	return nil
}

// Binds a value to the named input, to be used when RunWithBinding is called.
func (b *IoBinding) BindInput(name string, value Value) error {
	cName := ( /*line :2072:11*/_Cfunc_CString /*line :2072:19*/)(name)
	defer func() func() { _cgo0 := /*line :2073:15*/unsafe.Pointer(cName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :2073:37*/_Cfunc_free(_cgo0); }}()()
	ortValue := value.GetInternals().ortValue
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2075:24*/b.o; var _cgo1 *_Ctype_char = /*line :2075:29*/cName; _cgo2 := /*line :2075:36*/ortValue; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :2075:45*/_Cfunc_BindInput(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Binds a value to the named output, to be used when RunWithBinding is called.
func (b *IoBinding) BindOutput(name string, value Value) error {
	cName := ( /*line :2084:11*/_Cfunc_CString /*line :2084:19*/)(name)
	defer func() func() { _cgo0 := /*line :2085:15*/unsafe.Pointer(cName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :2085:37*/_Cfunc_free(_cgo0); }}()()
	ortValue := value.GetInternals().ortValue
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2087:25*/b.o; var _cgo1 *_Ctype_char = /*line :2087:30*/cName; _cgo2 := /*line :2087:37*/ortValue; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :2087:46*/_Cfunc_BindOutput(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Returns a list of bound output names, which will be returned in the same
// order that outputs will be returned when GetBoundOutputValues is called.
func (b *IoBinding) GetBoundOutputNames() ([]string, error) {
	var resultBuffer * /*line :2097:20*/_Ctype_char /*line :2097:26*/
	var resultCount  /*line :2098:18*/_Ctype_size_t /*line :2098:26*/
	var resultSizes * /*line :2099:19*/_Ctype_size_t /*line :2099:27*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2100:34*/b.o; _cgoBase1 := /*line :2100:39*/&resultBuffer; _cgo1 := _cgoBase1; _cgoBase2 := /*line :2100:54*/&resultSizes; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_size_t = /*line :2101:3*/&resultCount; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :2101:16*/_Cfunc_GetBoundOutputNames(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if status != nil {
		return nil, statusToError(status)
	}
	// The doc says no allocation occurs if the number of results is 0.
	if resultCount == 0 {
		return []string{}, nil
	}

	// Start by getting go slice views of the C buffers to make it easier to
	// work with.
	sizesSlice := unsafe.Slice(resultSizes, resultCount)
	totalSize := uint64(0)
	// There is likely a more efficient way, but it's much easier to just get
	// a go slice of the entire buffer. NOTE: The strings in this buffer are
	// *not* null terminated!
	for _, s := range sizesSlice {
		totalSize += uint64(s)
	}
	charsSlice := unsafe.Slice((*byte)(unsafe.Pointer(resultBuffer)),
		totalSize)

	// We'll take advantage of the byte-slice-to-string conversion to copy the
	// data into go-managed memory.
	toReturn := make([]string, resultCount)
	prevEndOffset := uint64(0)
	for i, stringLength := range sizesSlice {
		toReturn[i] = string(charsSlice[prevEndOffset:stringLength])
		prevEndOffset += uint64(stringLength)
	}

	// Finally, free the onnxruntime-allocated memory buffers. Always attempt
	// to free both buffers, even if one returns an error.
	status1 := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2134:43*/unsafe.Pointer(resultSizes); _cgoCheckPointer(_cgo0, nil); return /*line :2134:71*/_Cfunc_FreeWithDefaultORTAllocator(_cgo0); }()
	status2 := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2135:43*/unsafe.Pointer(resultBuffer); _cgoCheckPointer(_cgo0, nil); return /*line :2135:72*/_Cfunc_FreeWithDefaultORTAllocator(_cgo0); }()
	if status1 != nil {
		return toReturn, fmt.Errorf("Error freeing list of string lengths: %w",
			statusToError(status1))
	}
	if status2 != nil {
		return toReturn, fmt.Errorf("Error freeing buffer of output names: %w",
			statusToError(status2))
	}

	return toReturn, nil
}

// Returns a list of Values containing results of a model run using
// RunWithBinding. The returned slice contains the same number of values as the
// number of names returned by GetOutputNames, and/or in the same order as they
// were bound using IoBinding.BindOutput. IMPORTANT: Each Value returned by
// this function must be freed by the caller; they are _copies_.
//
// Note: Using this function will cause Tensor contents to be copied from
// C-managed to Go-managed memory to avoid leaks (this is similar to behavior
// when DynamicAdvancedSession.Run is allowed to automatically allocate
// output tensors). Note that this may be expensive for larger tensors.
func (b *IoBinding) GetBoundOutputValues() ([]Value, error) {
	var valuesBuffer ** /*line :2159:21*/_Ctype_OrtValue /*line :2159:31*/
	var numValues  /*line :2160:16*/_Ctype_size_t /*line :2160:24*/
	var e error
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2162:35*/b.o; _cgoBase1 := /*line :2162:40*/&valuesBuffer; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_size_t = /*line :2162:55*/&numValues; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :2162:66*/_Cfunc_GetBoundOutputValues(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return nil, statusToError(status)
	}
	valuesSlice := unsafe.Slice(valuesBuffer, numValues)

	toReturn := make([]Value, numValues)
	for i := range valuesSlice {
		toReturn[i], e = createGoValueFromOrtValue(valuesSlice[i])
		if e != nil {
			// Upon error, we have a lot to clean up:
			//  All OrtValues from C that haven't been converted...
			for _, v := range valuesSlice {
				if v != nil {
					func() { _cgo0 := /*line :2176:24*/v; _cgoCheckPointer(_cgo0, nil); /*line :2176:26*/_Cfunc_ReleaseOrtValue(_cgo0); }()
				}
			}
			// the valuesBuffer...
			func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2180:34*/unsafe.Pointer(valuesBuffer); _cgoCheckPointer(_cgo0, nil); return /*line :2180:63*/_Cfunc_FreeWithDefaultORTAllocator(_cgo0); }()
			// ... and any Go values that we've already converted
			for _, v := range toReturn {
				if v != nil {
					v.Destroy()
				}
			}

			// Finally, we can actually return the error. Hopefully this
			// doesn't happen often!
			return nil, fmt.Errorf("Error converting output index %d to "+
				"a Go-managed Value: %w", i, e)
		}
		// createGoValueFromOrtValue will automatically destroy the OrtValue,
		// or it will be destroyed when the corresponding Go Value is
		// Destroy()'d. Either way, we don't want to double-free it if we
		// attempt to clean up, so make it nil to indicate we're done with it.
		valuesSlice[i] = nil
	}

	// If we're here, everything was successfully converted to a Go value,
	// which implies the C-managed OrtValues have already been released or
	// will be released when the corresponding Go Value is destroyed.
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2203:41*/unsafe.Pointer(valuesBuffer); _cgoCheckPointer(_cgo0, nil); return /*line :2203:70*/_Cfunc_FreeWithDefaultORTAllocator(_cgo0); }()
	if status != nil {
		// The API is cleaner if the caller doesn't need to worry about
		// cleaning up if an error is returned.
		for _, v := range toReturn {
			v.Destroy()
		}
		return nil, fmt.Errorf("Error destroying C-managed buffer to hold "+
			"OrtValue pointers: %w", statusToError(status))
	}

	return toReturn, nil
}

// Clears any previously set inputs. Can't cause errors in the ORT C API.
func (b *IoBinding) ClearBoundInputs() {
	if b.o == nil {
		return
	}
	func() { _cgo0 := /*line :2222:21*/b.o; _cgoCheckPointer(_cgo0, nil); /*line :2222:25*/_Cfunc_ClearBoundInputs(_cgo0); }()
}

// Clears any previously set outputs. Can't cause errors in the ORT C API.
func (b *IoBinding) ClearBoundOutputs() {
	if b.o == nil {
		return
	}
	func() { _cgo0 := /*line :2230:22*/b.o; _cgoCheckPointer(_cgo0, nil); /*line :2230:26*/_Cfunc_ClearBoundOutputs(_cgo0); }()
}

// Creates and returns a ModelMetadata instance for this session's model. The
// returned metadata must be freed using its Destroy() function when no longer
// needed.
func (s *AdvancedSession) GetModelMetadata() (*ModelMetadata, error) {
	var m * /*line :2237:9*/_Ctype_OrtModelMetadata /*line :2237:27*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2238:38*/s.ortSession; _cgoBase1 := /*line :2238:52*/&m; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :2238:55*/_Cfunc_SessionGetModelMetadata(_cgo0, _cgo1); }()
	if status != nil {
		return nil, statusToError(status)
	}
	return &ModelMetadata{
		m: m,
	}, nil
}

// This type of session does not require specifying input and output tensors
// ahead of time, but allows users to pass the list of input and output tensors
// when calling Run(). As with AdvancedSession, users must still call Destroy()
// on an DynamicAdvancedSession that is no longer needed.
type DynamicAdvancedSession struct {
	// We may have further performance optimizations to this in the future, but
	// for now it's just a regular AdvancedSession.
	s *AdvancedSession
}

// Like NewAdvancedSessionWithONNXData, but does not require specifying input
// and output tensors.
func NewDynamicAdvancedSessionWithONNXData(onnxData []byte,
	inputNames, outputNames []string,
	options *SessionOptions) (*DynamicAdvancedSession, error) {
	s, e := newAdvancedSessionInternal(inputNames, outputNames, nil, nil, true)
	if e != nil {
		return nil, fmt.Errorf("Error creating internal AdvancedSession: %w",
			e)
	}
	s.ortSession, e = createCSession(onnxData, options)
	if e != nil {
		s.Destroy()
		return nil, fmt.Errorf("Error creating C session: %w", e)
	}
	return &DynamicAdvancedSession{
		s: s,
	}, nil
}

// Like NewAdvancedSession, but does not require specifying input and output
// tensors. Input and output names can be nil or empty, but _only if_ this
// session will only be used via RunWithBinding, which manages names
// separately.
func NewDynamicAdvancedSession(onnxFilePath string, inputNames,
	outputNames []string, options *SessionOptions) (*DynamicAdvancedSession,
	error) {
	s, e := newAdvancedSessionInternal(inputNames, outputNames, nil, nil, true)
	if e != nil {
		return nil, fmt.Errorf("Error creating internal AdvancedSession: %w",
			e)
	}
	s.ortSession, e = createCSessionFromFile(onnxFilePath, options)
	if e != nil {
		s.Destroy()
		return nil, fmt.Errorf("Error creating C session from file: %w", e)
	}
	return &DynamicAdvancedSession{
		s: s,
	}, nil
}

func (s *DynamicAdvancedSession) Destroy() error {
	return s.s.Destroy()
}

func createTensorWithCData[T TensorData](shape Shape,
	data unsafe.Pointer) (*Tensor[T], error) {
	totalCount := shape.FlattenedSize()
	actualData := unsafe.Slice((*T)(data), totalCount)
	dataCopy := make([]T, totalCount)
	copy(dataCopy, actualData)
	return NewTensor[T](shape, dataCopy)
}

// Returns the Shape described by a TensorTypeAndShapeInfo instance.
func getShapeFromInfo(t * /*line :2313:26*/_Ctype_OrtTensorTypeAndShapeInfo /*line :2313:53*/) (Shape, error) {
	var dimCount  /*line :2314:15*/_Ctype_size_t /*line :2314:23*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2315:33*/t; var _cgo1 *_Ctype_size_t = /*line :2315:36*/&dimCount; _cgoCheckPointer(_cgo0, nil); return /*line :2315:46*/_Cfunc_GetDimensionsCount(_cgo0, _cgo1); }()
	if status != nil {
		return nil, fmt.Errorf("Error getting dimension count: %w",
			statusToError(status))
	}
	if dimCount == 0 {
		// Apparently some models will report shapes with zero dimensions
		return Shape{}, nil
	}
	shape := make(Shape, dimCount)
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2325:27*/t; var _cgo1 *_Ctype_int64_t = /*line :2325:30*/(*_Ctype_int64_t /*line :2325:41*/)(&shape[0]); var _cgo2 _Ctype_size_t = /*line :2325:55*/dimCount; _cgoCheckPointer(_cgo0, nil); return /*line :2325:64*/_Cfunc_GetDimensions(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return nil, fmt.Errorf("Error getting shape dimensions: %w",
			statusToError(status))
	}
	return shape, nil
}

// Returns the ONNXType associated with a C OrtValue.
func getValueType(v * /*line :2334:22*/_Ctype_OrtValue /*line :2334:32*/) (ONNXType, error) {
	var t  /*line :2335:8*/_Ctype_enum_ONNXType /*line :2335:23*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2336:27*/v; var _cgo1 *uint32 = /*line :2336:30*/&t; _cgoCheckPointer(_cgo0, nil); return /*line :2336:33*/_Cfunc_GetValueType(_cgo0, _cgo1); }()
	if status != nil {
		return ONNXTypeUnknown, fmt.Errorf("Error looking up type for "+
			"OrtValue: %s", statusToError(status))
	}
	return ONNXType(t), nil
}

// Returns the "count" associated with an OrtValue. Mostly useful for
// sequences. Should always return 2 for a map. Not sure what it returns for
// Tensors, but that shouldn't matter.
func getValueCount(v * /*line :2347:23*/_Ctype_OrtValue /*line :2347:33*/) (int64, error) {
	var size  /*line :2348:11*/_Ctype_size_t /*line :2348:19*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2349:28*/v; var _cgo1 *_Ctype_size_t = /*line :2349:31*/&size; _cgoCheckPointer(_cgo0, nil); return /*line :2349:37*/_Cfunc_GetValueCount(_cgo0, _cgo1); }()
	if status != nil {
		return 0, fmt.Errorf("Error getting non tensor count for OrtValue: %s",
			statusToError(status))
	}
	return int64(size), nil
}

// Takes an OrtValue and returns an appropriate Go value wrapping it, or at
// least an equivalent go value in case v is a Tensor. The Value v should
// _not_ be released after calling this function; it will either be released
// internally or released when the returned Value is Destroy()'d. (Callers must
// destroy the returned value.)
//
// If this function fails, v will be released.
func createGoValueFromOrtValue(v * /*line :2364:35*/_Ctype_OrtValue /*line :2364:45*/) (Value, error) {
	if v == nil {
		return nil, fmt.Errorf("Internal error: got nil argument to " +
			"createGoValueFromOrtValue")
	}
	valueType, e := getValueType(v)
	if e != nil {
		func() { _cgo0 := /*line :2371:21*/v; _cgoCheckPointer(_cgo0, nil); /*line :2371:23*/_Cfunc_ReleaseOrtValue(_cgo0); }()
		return nil, e
	}
	switch valueType {
	case ONNXTypeTensor:
		return createTensorFromOrtValue(v)
	case ONNXTypeSequence:
		return createSequenceFromOrtValue(v)
	case ONNXTypeMap:
		return createMapFromOrtValue(v)
	default:
		break
	}
	func() { _cgo0 := /*line :2384:20*/v; _cgoCheckPointer(_cgo0, nil); /*line :2384:22*/_Cfunc_ReleaseOrtValue(_cgo0); }()
	return nil, fmt.Errorf("It is currently not supported to create a Go "+
		"value from OrtValues with ONNXType = %s", valueType)
}

// Must only be called if v is known to be of type ONNXTensor. Returns a Tensor
// wrapping v with the correct Go type. This function always copies v's
// contents into a new Tensor backed by a Go-managed slice and releases v.
func createTensorFromOrtValue(v * /*line :2392:34*/_Ctype_OrtValue /*line :2392:44*/) (Value, error) {
	// Either in the case of error or otherwise, we'll release v. The issue is
	// that GetTensorMutableData() becomes invalid after v is Released, so we
	// can't release v if a reference to the slice returned by GetData is
	// still referred to outside of the tensor. We work around this by copying
	// the data into a new tensor and releasing the original.
	defer func() func() { _cgo0 := /*line :2398:26*/v; return func() { _cgoCheckPointer(_cgo0, nil); /*line :2398:28*/_Cfunc_ReleaseOrtValue(_cgo0); }}()()

	var pInfo * /*line :2400:13*/_Ctype_OrtTensorTypeAndShapeInfo /*line :2400:40*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2401:36*/v; _cgoBase1 := /*line :2401:39*/&pInfo; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :2401:46*/_Cfunc_GetTensorTypeAndShape(_cgo0, _cgo1); }()
	if status != nil {
		return nil, fmt.Errorf("Error getting type and shape: %w",
			statusToError(status))
	}
	shape, e := getShapeFromInfo(pInfo)
	if e != nil {
		return nil, fmt.Errorf("Error getting shape from TypeAndShapeInfo: %w",
			e)
	}
	var tensorElementType  /*line :2411:24*/_Ctype_ONNXTensorElementDataType /*line :2411:51*/
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2412:34*/pInfo; var _cgo1 *uint32 = /*line :2412:41*/(*uint32)(&tensorElementType); _cgoCheckPointer(_cgo0, nil); return /*line :2412:71*/_Cfunc_GetTensorElementType(_cgo0, _cgo1); }()
	if status != nil {
		return nil, fmt.Errorf("Error getting tensor element type: %w",
			statusToError(status))
	}
	func() { _cgo0 := /*line :2417:34*/pInfo; _cgoCheckPointer(_cgo0, nil); /*line :2417:40*/_Cfunc_ReleaseTensorTypeAndShapeInfo(_cgo0); }()
	var tensorData unsafe.Pointer
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2419:34*/v; _cgoBase1 := /*line :2419:37*/&tensorData; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :2419:49*/_Cfunc_GetTensorMutableData(_cgo0, _cgo1); }()
	if status != nil {
		return nil, fmt.Errorf("Error getting tensor mutable data: %w",
			statusToError(status))
	}

	switch tensorType := TensorElementDataType(tensorElementType); tensorType {
	case TensorElementDataTypeFloat:
		return createTensorWithCData[float32](shape, tensorData)
	case TensorElementDataTypeUint8:
		return createTensorWithCData[uint8](shape, tensorData)
	case TensorElementDataTypeInt8:
		return createTensorWithCData[int8](shape, tensorData)
	case TensorElementDataTypeUint16:
		return createTensorWithCData[uint16](shape, tensorData)
	case TensorElementDataTypeInt16:
		return createTensorWithCData[int16](shape, tensorData)
	case TensorElementDataTypeInt32:
		return createTensorWithCData[int32](shape, tensorData)
	case TensorElementDataTypeInt64:
		return createTensorWithCData[int64](shape, tensorData)
	case TensorElementDataTypeDouble:
		return createTensorWithCData[float64](shape, tensorData)
	case TensorElementDataTypeUint32:
		return createTensorWithCData[uint32](shape, tensorData)
	case TensorElementDataTypeUint64:
		return createTensorWithCData[uint64](shape, tensorData)
	case TensorElementDataTypeBool:
		return createTensorWithCData[bool](shape, tensorData)
	default:
		totalSize := shape.FlattenedSize()
		actualData := unsafe.Slice((*byte)(tensorData), totalSize)
		dataCopy := make([]byte, totalSize)
		copy(dataCopy, actualData)
		return NewCustomDataTensor(shape, dataCopy, tensorType)
	}
}

// Must only be called if v is already known to be an ONNXTypeSequence. Returns
// a Sequence go type wrapping v. Releases v if an error occurs; otherwise v
// will be released when the returned Sequence is destroyed.
func createSequenceFromOrtValue(v * /*line :2460:36*/_Ctype_OrtValue /*line :2460:46*/) (*Sequence, error) {
	length, e := getValueCount(v)
	if e != nil {
		func() { _cgo0 := /*line :2463:21*/v; _cgoCheckPointer(_cgo0, nil); /*line :2463:23*/_Cfunc_ReleaseOrtValue(_cgo0); }()
		return nil, fmt.Errorf("Error determining sequence length: %w", e)
	}

	// Retrieve all of the sequence's contents as Go values, too.
	internalValues := make([]Value, length)
	for i := range internalValues {
		internalValues[i], e = getSequenceOrMapValue(v, int64(i))
		if e != nil {
			// Clean up whatever values we already created.
			for j := 0; j < i; j++ {
				internalValues[i].Destroy()
			}
			func() { _cgo0 := /*line :2476:22*/v; _cgoCheckPointer(_cgo0, nil); /*line :2476:24*/_Cfunc_ReleaseOrtValue(_cgo0); }()
			return nil, fmt.Errorf("Error retrieving sequence contents at "+
				"index %d: %w", i, e)
		}
	}

	return &Sequence{
		ortValue: v,
		contents: internalValues,
	}, nil
}

// Must only be called if v is already known to be an ONNXTypeMap. Returns a
// Map go type wrapping v. Releases v if an error occurs, otherwise v will be
// released when the returned Map is destroyed.
func createMapFromOrtValue(v * /*line :2491:31*/_Ctype_OrtValue /*line :2491:41*/) (*Map, error) {
	// Obtain the keys and values as tensors from the Map instance.
	keys, e := getSequenceOrMapValue(v, 0)
	if e != nil {
		func() { _cgo0 := /*line :2495:21*/v; _cgoCheckPointer(_cgo0, nil); /*line :2495:23*/_Cfunc_ReleaseOrtValue(_cgo0); }()
		return nil, fmt.Errorf("Error getting keys tensor from map: %w", e)
	}
	values, e := getSequenceOrMapValue(v, 1)
	if e != nil {
		keys.Destroy()
		func() { _cgo0 := /*line :2501:21*/v; _cgoCheckPointer(_cgo0, nil); /*line :2501:23*/_Cfunc_ReleaseOrtValue(_cgo0); }()
		return nil, fmt.Errorf("Error getting values tensor from map: %w", e)
	}

	return &Map{
		ortValue: v,
		keys:     keys,
		values:   values,
	}, nil
}

// Runs the network on the given input and output tensors. The number of input
// and output tensors must match the number (and order) of the input and output
// names specified to NewDynamicAdvancedSession. If a given output is nil, it
// will be allocated and the slice will be modified to include the new Value.
// Any new Value allocated in this way must be freed by calling Destroy on it.
func (s *DynamicAdvancedSession) Run(inputs, outputs []Value) error {
	// Delegate to RunWithOptions to unify input/output validation,
	// optional output auto-allocation and conversion logic.
	return s.RunWithOptions(inputs, outputs, nil)
}

func (s *DynamicAdvancedSession) RunWithOptions(inputs, outputs []Value, opts *RunOptions) error {
	if len(inputs) != len(s.s.inputNames) {
		return fmt.Errorf("The session specified %d input names, but Run() "+
			"was called with %d input tensors", len(s.s.inputNames),
			len(inputs))
	}
	if len(outputs) != len(s.s.outputNames) {
		return fmt.Errorf("The session specified %d output names, but Run() "+
			"was called with %d output tensors", len(s.s.outputNames),
			len(outputs))
	}
	inputValues := make([]* /*line :2534:25*/_Ctype_OrtValue /*line :2534:35*/, len(inputs))
	for i, v := range inputs {
		inputValues[i] = v.GetInternals().ortValue
	}
	outputValues := make([]* /*line :2538:26*/_Ctype_OrtValue /*line :2538:36*/, len(outputs))
	for i, v := range outputs {
		if v == nil {
			// Leave any output that needs to be allocated as nil.
			continue
		}
		outputValues[i] = v.GetInternals().ortValue
	}
	var optsPtr * /*line :2546:15*/_Ctype_OrtRunOptions /*line :2546:30*/
	if opts != nil {
		optsPtr = opts.o
	}
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2550:39*/s.s.ortSession; _cgoIndex1 := &/*line :2550:56*/inputValues; _cgo1 := /*line :2550:55*/&(*_cgoIndex1)[0]; _cgoIndex2 := &/*line :2551:4*/s.s.inputNames; _cgo2 := /*line :2551:3*/&(*_cgoIndex2)[0]; var _cgo3 _Ctype_int = _Ctype_int /*line :2551:28*/(len(inputs)); _cgoIndex4 := &/*line :2551:44*/outputValues; _cgo4 := /*line :2551:43*/&(*_cgoIndex4)[0]; _cgoIndex5 := &/*line :2552:4*/s.s.outputNames; _cgo5 := /*line :2552:3*/&(*_cgoIndex5)[0]; var _cgo6 _Ctype_int = _Ctype_int /*line :2552:29*/(len(outputs)); _cgo7 := /*line :2552:45*/optsPtr; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); _cgoCheckPointer(_cgo2, *_cgoIndex2); _cgoCheckPointer(_cgo4, *_cgoIndex4); _cgoCheckPointer(_cgo5, *_cgoIndex5); _cgoCheckPointer(_cgo7, nil); return /*line :2552:53*/_Cfunc_RunOrtSessionWithOptions(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
	if status != nil {
		return fmt.Errorf("Error running network: %w", statusToError(status))
	}
	// Convert any automatically-allocated output to a go Value.
	for i, v := range outputs {
		if v != nil {
			continue
		}
		var err error
		outputs[i], err = createGoValueFromOrtValue(outputValues[i])
		if err != nil {
			return fmt.Errorf("Error creating tensor from ort: %w", err)
		}
	}
	return nil
}

// Runs the session using the given IoBinding instance. The IoBinding must
// have been created from this session's CreateIoBinding() function.
func (s *DynamicAdvancedSession) RunWithBinding(b *IoBinding) error {
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2573:36*/s.s.ortSession; _cgo1 := /*line :2573:52*/b.o; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :2573:56*/_Cfunc_RunSessionWithBinding(_cgo0, _cgo1); }()
	if status != nil {
		return statusToError(status)
	}
	return nil
}

// Creates and returns a ModelMetadata instance for this session's model. The
// returned metadata must be freed using its Destroy() function when no longer
// needed.
func (s *DynamicAdvancedSession) GetModelMetadata() (*ModelMetadata, error) {
	return s.s.GetModelMetadata()
}

// Holds information about the name, shape, and type of an input or output to a
// ONNX network.
type InputOutputInfo struct {
	// The name of the input or output
	Name string
	// The higher-level "type" of the output; whether it's a tensor, sequence,
	// map, etc.
	OrtValueType ONNXType
	// The input or output's dimensions, if it's a tensor. This should be
	// ignored for non-tensor types.
	Dimensions Shape
	// The type of element in the input or output, if it's a tensor. This
	// should be ignored for non-tensor types.
	DataType TensorElementDataType
}

func (n *InputOutputInfo) String() string {
	switch n.OrtValueType {
	case ONNXTypeUnknown:
		return fmt.Sprintf("Unknown ONNX type: %s", n.Name)
	case ONNXTypeTensor:
		return fmt.Sprintf("Tensor \"%s\": %s, %s", n.Name, n.Dimensions,
			n.DataType)
	case ONNXTypeSequence:
		return fmt.Sprintf("Sequence \"%s\"", n.Name)
	case ONNXTypeMap:
		return fmt.Sprintf("Map \"%s\"", n.Name)
	case ONNXTypeOpaque:
		return fmt.Sprintf("Opaque \"%s\"", n.Name)
	case ONNXTypeSparseTensor:
		return fmt.Sprintf("Sparse tensor \"%s\": dense shape %s, %s",
			n.Name, n.Dimensions, n.DataType)
	case ONNXTypeOptional:
		return fmt.Sprintf("Optional \"%s\"", n.Name)
	default:
		break
	}
	// We'll use the ONNXType String() output if we don't know the type.
	return fmt.Sprintf("%s: \"%s\"", n.OrtValueType, n.Name)
}

// Sets o.OrtValueType, o.DataType, and o.Dimensions from the contents of t.
func (o *InputOutputInfo) fillFromTypeInfo(t * /*line :2629:47*/_Ctype_OrtTypeInfo /*line :2629:60*/) error {
	var onnxType  /*line :2630:15*/_Ctype_enum_ONNXType /*line :2630:30*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2631:38*/t; var _cgo1 *uint32 = /*line :2631:41*/&onnxType; _cgoCheckPointer(_cgo0, nil); return /*line :2631:51*/_Cfunc_GetONNXTypeFromTypeInfo(_cgo0, _cgo1); }()
	if status != nil {
		return fmt.Errorf("Error getting ONNX type: %s", statusToError(status))
	}
	o.OrtValueType = ONNXType(onnxType)
	o.Dimensions = nil
	o.DataType = TensorElementDataTypeUndefined

	// We only fill in element type and dimensions if we're dealing with a
	// tensor of some sort.
	isTensorType := (o.OrtValueType == ONNXTypeTensor) ||
		(o.OrtValueType == ONNXTypeSparseTensor)
	if !isTensorType {
		return nil
	}

	// OrtTensorTypeAndShapeInfo pointers should *not* be released if they're
	// obtained via CastTypeInfoToTensorInfo.
	var typeAndShapeInfo * /*line :2649:24*/_Ctype_OrtTensorTypeAndShapeInfo /*line :2649:51*/
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2650:38*/t; _cgoBase1 := /*line :2650:41*/&typeAndShapeInfo; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :2650:59*/_Cfunc_CastTypeInfoToTensorInfo(_cgo0, _cgo1); }()
	if status != nil {
		return fmt.Errorf("Error getting type and shape info: %w",
			statusToError(status))
	}
	if typeAndShapeInfo == nil {
		return fmt.Errorf("Didn't get type and shape info for an OrtTypeInfo" +
			"(it may not be a tensor type?)")
	}
	var e error
	o.Dimensions, e = getShapeFromInfo(typeAndShapeInfo)
	if e != nil {
		return fmt.Errorf("Error getting shape from typeAndShapeInfo: %w", e)
	}
	var tensorElementType  /*line :2664:24*/_Ctype_ONNXTensorElementDataType /*line :2664:51*/
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2665:34*/typeAndShapeInfo; var _cgo1 *uint32 = /*line :2666:3*/(*uint32)(&tensorElementType); _cgoCheckPointer(_cgo0, nil); return /*line :2666:33*/_Cfunc_GetTensorElementType(_cgo0, _cgo1); }()
	if status != nil {
		return fmt.Errorf("Error getting data type from typeAndShapeInfo: %w",
			statusToError(status))
	}
	o.DataType = TensorElementDataType(tensorElementType)
	return nil
}

// Fills dst with information about the session's i'th input.
func getSessionInputInfo(s * /*line :2676:29*/_Ctype_OrtSession /*line :2676:41*/, i int, dst *InputOutputInfo) error {
	var cName * /*line :2677:13*/_Ctype_char /*line :2677:19*/
	var e error
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2679:34*/s; var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :2679:45*/(i); _cgoBase2 := /*line :2679:50*/&cName; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :2679:57*/_Cfunc_SessionGetInputName(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return fmt.Errorf("Error getting name: %w", statusToError(status))
	}
	dst.Name, e = convertORTString(cName)
	if e != nil {
		return fmt.Errorf("Error converting C name to Go string: %w", e)
	}

	// Session inputs are reported as OrtTypeInfo structs, though usually we
	// want a tensor-specific OrtTensorTypeAndShapeInfo struct, which we can
	// get from the type info.
	var typeInfo * /*line :2691:16*/_Ctype_OrtTypeInfo /*line :2691:29*/
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2692:37*/s; var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :2692:48*/(i); _cgoBase2 := /*line :2692:53*/&typeInfo; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :2692:63*/_Cfunc_SessionGetInputTypeInfo(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return fmt.Errorf("Error getting type info: %w", statusToError(status))
	}
	defer func() func() { _cgo0 := /*line :2696:26*/typeInfo; return func() { _cgoCheckPointer(_cgo0, nil); /*line :2696:35*/_Cfunc_ReleaseTypeInfo(_cgo0); }}()()
	e = dst.fillFromTypeInfo(typeInfo)
	if e != nil {
		return e
	}
	return nil
}

// Fills dst with information about the session's i'th output.
func getSessionOutputInfo(s * /*line :2705:30*/_Ctype_OrtSession /*line :2705:42*/, i int, dst *InputOutputInfo) error {
	// This is basically identical to getSessionInputInfo.
	var cName * /*line :2707:13*/_Ctype_char /*line :2707:19*/
	var e error
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2709:35*/s; var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :2709:46*/(i); _cgoBase2 := /*line :2709:51*/&cName; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :2709:58*/_Cfunc_SessionGetOutputName(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return fmt.Errorf("Error getting name: %w", statusToError(status))
	}
	dst.Name, e = convertORTString(cName)
	if e != nil {
		return fmt.Errorf("Error converting C name to Go string: %w", e)
	}
	var typeInfo * /*line :2717:16*/_Ctype_OrtTypeInfo /*line :2717:29*/
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2718:38*/s; var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :2718:49*/(i); _cgoBase2 := /*line :2718:54*/&typeInfo; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :2718:64*/_Cfunc_SessionGetOutputTypeInfo(_cgo0, _cgo1, _cgo2); }()
	if status != nil {
		return fmt.Errorf("Error getting type info: %w", statusToError(status))
	}
	defer func() func() { _cgo0 := /*line :2722:26*/typeInfo; return func() { _cgoCheckPointer(_cgo0, nil); /*line :2722:35*/_Cfunc_ReleaseTypeInfo(_cgo0); }}()()
	e = dst.fillFromTypeInfo(typeInfo)
	if e != nil {
		return e
	}
	return nil
}

// Takes an initialized OrtSession and returns slices of info for each input
// and output, respectively. Used internally by GetInputOutputInfo, etc.
func getInputOutputInfoFromCSession(s * /*line :2732:40*/_Ctype_OrtSession /*line :2732:52*/) ([]InputOutputInfo,
	[]InputOutputInfo, error) {
	var e error

	// Allocate the structs to hold the results.
	var inputCount, outputCount  /*line :2737:30*/_Ctype_size_t /*line :2737:38*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2738:35*/s; var _cgo1 *_Ctype_size_t = /*line :2738:38*/&inputCount; _cgoCheckPointer(_cgo0, nil); return /*line :2738:50*/_Cfunc_SessionGetInputCount(_cgo0, _cgo1); }()
	if status != nil {
		return nil, nil, statusToError(status)
	}
	inputs := make([]InputOutputInfo, inputCount)
	status = func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2743:35*/s; var _cgo1 *_Ctype_size_t = /*line :2743:38*/&outputCount; _cgoCheckPointer(_cgo0, nil); return /*line :2743:51*/_Cfunc_SessionGetOutputCount(_cgo0, _cgo1); }()
	if status != nil {
		return nil, nil, statusToError(status)
	}
	outputs := make([]InputOutputInfo, outputCount)

	// Get the results for each input and output.
	for i := 0; i < int(inputCount); i++ {
		e = getSessionInputInfo(s, i, &(inputs[i]))
		if e != nil {
			return nil, nil, fmt.Errorf("Error getting information about "+
				"input %d: %w", i, e)
		}
	}
	for i := 0; i < int(outputCount); i++ {
		e = getSessionOutputInfo(s, i, &(outputs[i]))
		if e != nil {
			return nil, nil, fmt.Errorf("Error getting information about "+
				"output %d: %w", i, e)
		}
	}
	return inputs, outputs, nil
}

// Takes a path to a .onnx file, and returns a list of inputs and a list of
// outputs, respectively. Will open, read, and close the .onnx file to get the
// information. InitializeEnvironment() must have been called prior to using
// this function. Warning: this function requires loading the .onnx file into a
// temporary onnxruntime session, which may be an expensive operation.
//
// For now, this may fail if the network has any non-tensor inputs or inputs
// that don't have a concrete shape and type. In the future, a new API may be
// added to support cases requiring more advanced usage of the C.OrtTypeInfo
// struct.
func GetInputOutputInfo(path string) ([]InputOutputInfo, []InputOutputInfo,
	error) {
	return GetInputOutputInfoWithOptions(path, nil)
}

// Identical in behavior to GetInputOutputInfo, but addtionally takes
// session options to handle models that require options to load.
func GetInputOutputInfoWithOptions(path string,
	options *SessionOptions) ([]InputOutputInfo, []InputOutputInfo, error) {
	s, e := createCSessionFromFile(path, options)
	if e != nil {
		return nil, nil, fmt.Errorf("Error loading temporary session: %w", e)
	}
	defer func() func() { _cgo0 := /*line :2790:28*/s; return func() { _cgoCheckPointer(_cgo0, nil); /*line :2790:30*/_Cfunc_ReleaseOrtSession(_cgo0); }}()()
	return getInputOutputInfoFromCSession(s)
}

// Identical in behavior to GetInputOutputInfo, but takes a slice of bytes
// containing the .onnx network rather than a file path.
func GetInputOutputInfoWithONNXData(data []byte) ([]InputOutputInfo,
	[]InputOutputInfo, error) {
	var e error
	s, e := createCSession(data, nil)
	if e != nil {
		return nil, nil, fmt.Errorf("Error creating temporary session: %w", e)
	}
	defer func() func() { _cgo0 := /*line :2803:28*/s; return func() { _cgoCheckPointer(_cgo0, nil); /*line :2803:30*/_Cfunc_ReleaseOrtSession(_cgo0); }}()()
	return getInputOutputInfoFromCSession(s)
}

func getModelMetadataFromCSession(s * /*line :2807:38*/_Ctype_OrtSession /*line :2807:50*/) (*ModelMetadata, error) {
	var m * /*line :2808:9*/_Ctype_OrtModelMetadata /*line :2808:27*/
	status := func() *_Ctype_struct_OrtStatus{ _cgo0 := /*line :2809:38*/s; _cgoBase1 := /*line :2809:41*/&m; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :2809:44*/_Cfunc_SessionGetModelMetadata(_cgo0, _cgo1); }()
	if status != nil {
		return nil, statusToError(status)
	}
	return &ModelMetadata{
		m: m,
	}, nil
}

// Takes a path to a .onnx file and returns the ModelMetadata associated with
// it. The returned metadata must be freed using its Destroy() function when
// it's no longer needed. InitializeEnvironment() must be called before using
// this function.
//
// Warning: This function loads the onnx content into a temporary onnxruntime
// session, so it may be computationally expensive.
func GetModelMetadata(path string) (*ModelMetadata, error) {
	return GetModelMetadataWithOptions(path, nil)
}

// Identical in behavior to GetModelMetadata, but addtionally takes
// session options to handle models that require options to load.
func GetModelMetadataWithOptions(path string,
	options *SessionOptions) (*ModelMetadata, error) {
	s, e := createCSessionFromFile(path, options)
	if e != nil {
		return nil, fmt.Errorf("Error loading %s: %w", path, e)
	}
	defer func() func() { _cgo0 := /*line :2837:28*/s; return func() { _cgoCheckPointer(_cgo0, nil); /*line :2837:30*/_Cfunc_ReleaseOrtSession(_cgo0); }}()()
	return getModelMetadataFromCSession(s)
}

// Identical in behavior to GetModelMetadata, but takes a slice of bytes
// containing the .onnx network rather than a file path.
func GetModelMetadataWithONNXData(data []byte) (*ModelMetadata, error) {
	if !IsInitialized() {
		return nil, NotInitializedError
	}
	// Create the temporary ORT session from which we'll get the metadata.
	s, e := createCSession(data, nil)
	if e != nil {
		return nil, fmt.Errorf("Error creating temporary session: %w", e)
	}
	defer func() func() { _cgo0 := /*line :2852:28*/s; return func() { _cgoCheckPointer(_cgo0, nil); /*line :2852:30*/_Cfunc_ReleaseOrtSession(_cgo0); }}()()
	return getModelMetadataFromCSession(s)
}
