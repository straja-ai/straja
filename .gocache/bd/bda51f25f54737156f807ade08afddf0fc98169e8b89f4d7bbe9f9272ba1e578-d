// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/sorinmanole/go/pkg/mod/github.com/yalue/onnxruntime_go@v1.23.0/setup_env.go:1:1
//go:build !windows

package onnxruntime_go; import _cgo_unsafe "unsafe"

import (
	"fmt"
	"runtime"
	"unsafe"
)

/*
#cgo LDFLAGS: -ldl

#include <dlfcn.h>
#include "onnxruntime_wrapper.h"

typedef OrtApiBase* (*GetOrtApiBaseFunction)(void);

// Since Go can't call C function pointers directly, we just use this helper
// when calling GetApiBase
OrtApiBase *CallGetAPIBaseFunction(void *fn) {
	OrtApiBase *to_return = ((GetOrtApiBaseFunction) fn)();
	return to_return;
}
*/
import _ "unsafe"

// This file includes the code for loading the onnxruntime and setting up the
// environment on non-Windows systems. For now, it has been tested on Linux and
// arm64 OSX.

// This will contain the handle to the onnxruntime shared library if it has
// been loaded successfully.
var libraryHandle unsafe.Pointer

func platformCleanup() error {
	v, e := func() (_Ctype_int, error){ _cgo0 := /*line :37:20*/libraryHandle; _cgoCheckPointer(_cgo0, nil); return /*line :37:34*/_C2func_dlclose(_cgo0); }()
	if v != 0 {
		return fmt.Errorf("Error closing the library: %w", e)
	}
	return nil
}

// Should only be called on Apple systems; looks up the CoreML provider
// function which should only be exported on apple onnxruntime dylib files.
func setAppendCoreMLFunctionPointer(libraryHandle unsafe.Pointer) error {
	// This function name must match the name in coreml_provider_factory.h,
	// which is provided in the onnxruntime release's include/ directory on for
	// Apple platforms.
	fnName := "OrtSessionOptionsAppendExecutionProvider_CoreML"
	cFunctionName := ( /*line :51:19*/_Cfunc_CString /*line :51:27*/)(fnName)
	defer func() func() { _cgo0 := /*line :52:15*/unsafe.Pointer(cFunctionName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :52:45*/_Cfunc_free(_cgo0); }}()()
	appendCoreMLProviderProc := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :53:38*/libraryHandle; var _cgo1 *_Ctype_char = /*line :53:53*/cFunctionName; _cgoCheckPointer(_cgo0, nil); return /*line :53:67*/_Cfunc_dlsym(_cgo0, _cgo1); }()
	if appendCoreMLProviderProc == nil {
		msg := ( /*line :55:10*/_Cfunc_GoString /*line :55:19*/)(( /*line :55:21*/_Cfunc_dlerror /*line :55:29*/)())
		return fmt.Errorf("Error looking up %s: %s", fnName, msg)
	}
	func() { _cgo0 := /*line :58:37*/appendCoreMLProviderProc; _cgoCheckPointer(_cgo0, nil); /*line :58:62*/_Cfunc_SetCoreMLProviderFunctionPointer(_cgo0); }()
	return nil
}

func platformInitializeEnvironment() error {
	if onnxSharedLibraryPath == "" {
		onnxSharedLibraryPath = "onnxruntime.so"
	}
	cName := ( /*line :66:11*/_Cfunc_CString /*line :66:19*/)(onnxSharedLibraryPath)
	defer func() func() { _cgo0 := /*line :67:15*/unsafe.Pointer(cName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :67:37*/_Cfunc_free(_cgo0); }}()()
	handle := ( /*line :68:12*/_Cfunc_dlopen /*line :68:19*/)(cName, ( /*line :68:28*/_Ciconst_RTLD_LAZY /*line :68:38*/))
	if handle == nil {
		msg := ( /*line :70:10*/_Cfunc_GoString /*line :70:19*/)(( /*line :70:21*/_Cfunc_dlerror /*line :70:29*/)())
		return fmt.Errorf("Error loading ONNX shared library \"%s\": %s",
			onnxSharedLibraryPath, msg)
	}
	cFunctionName := ( /*line :74:19*/_Cfunc_CString /*line :74:27*/)("OrtGetApiBase")
	defer func() func() { _cgo0 := /*line :75:15*/unsafe.Pointer(cFunctionName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :75:45*/_Cfunc_free(_cgo0); }}()()
	getAPIBaseProc := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :76:28*/handle; var _cgo1 *_Ctype_char = /*line :76:36*/cFunctionName; _cgoCheckPointer(_cgo0, nil); return /*line :76:50*/_Cfunc_dlsym(_cgo0, _cgo1); }()
	if getAPIBaseProc == nil {
		func() _Ctype_int{ _cgo0 := /*line :78:13*/handle; _cgoCheckPointer(_cgo0, nil); return /*line :78:20*/_Cfunc_dlclose(_cgo0); }()
		msg := ( /*line :79:10*/_Cfunc_GoString /*line :79:19*/)(( /*line :79:21*/_Cfunc_dlerror /*line :79:29*/)())
		return fmt.Errorf("Error looking up OrtGetApiBase in \"%s\": %s",
			onnxSharedLibraryPath, msg)
	}
	ortAPIBase := func() *_Ctype_struct_OrtApiBase{ _cgo0 := /*line :83:41*/getAPIBaseProc; _cgoCheckPointer(_cgo0, nil); return /*line :83:56*/_Cfunc_CallGetAPIBaseFunction(_cgo0); }()
	tmp := func() _Ctype_int{ _cgo0 := /*line :84:26*/(*_Ctype_OrtApiBase /*line :84:40*/)(unsafe.Pointer(ortAPIBase)); _cgoCheckPointer(_cgo0, nil); return /*line :84:70*/_Cfunc_SetAPIFromBase(_cgo0); }()
	if tmp != 0 {
		func() _Ctype_int{ _cgo0 := /*line :86:13*/handle; _cgoCheckPointer(_cgo0, nil); return /*line :86:20*/_Cfunc_dlclose(_cgo0); }()
		return fmt.Errorf("Error setting ORT API base: %d", tmp)
	}
	if (runtime.GOOS == "darwin") || (runtime.GOOS == "ios") {
		setAppendCoreMLFunctionPointer(handle)
		// We'll silently ignore potential errors returned by
		// setAppendCoreMLFunctionPointer (for now at least). Even though we're
		// on Apple hardware, it's possible that the user will have compiled
		// the onnxruntime library from source without CoreML support.
		// A failure here will only leave the coreml function pointer as NULL
		// in our C code, which will be detected and result in an error at
		// runtime.
	}
	libraryHandle = handle
	return nil
}

// Converts the given path to an ORTCHAR_T string, pointed to by a *C.char. The
// returned string must be freed using C.free when no longer needed. This
// wrapper is used for source compatibility with onnxruntime API functions
// requiring paths, which must be UTF-16 on Windows but UTF-8 elsewhere.
func createOrtCharString(str string) (* /*line :107:40*/_Ctype_char /*line :107:46*/, error) {
	return ( /*line :108:9*/_Cfunc_CString /*line :108:17*/)(str), nil
}
